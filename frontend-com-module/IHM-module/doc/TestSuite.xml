<?xml version="1.0" encoding="UTF-8"?>
<Test_Suite>

<Test>
		<ID>1</ID>
		<API>1</API>
		<Name>TCP_BASICS_01</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST send a SYN,ACK in response to a SYN in LISTEN state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>2</ID>
		<API>2</API>
		<Name>TCP_BASICS_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST move on to ESTABLISHED state after receiving ACK in SYN-RCVD state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>3</ID>
		<API>3</API>
		<Name>TCP_BASICS_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST send an ACK in response to a FIN received in ESTABLISHED state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>4</ID>
		<API>4</API>
		<Name>TCP_BASICS_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSED state, MUST send a RST segment with zero SEQ number in response to an incoming segment not containing RST and ACK flags</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>5</ID>
		<API>5</API>
		<Name>TCP_BASICS_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSED state, MUST send a RST in response to an incoming segment containing ACK and not containing RST and SEQ number is taken from SEG.ACK</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>6</ID>
		<API>6</API>
		<Name>TCP_BASICS_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSED state, MUST send a SYN on an active OPEN call</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>7</ID>
		<API>7</API>
		<Name>TCP_BASICS_07</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be capable of progressing to ESTABLISHED state after receiving SYN,ACK in SYN-SENT state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>8</ID>
		<API>8</API>
		<Name>TCP_BASICS_08</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST send a FIN on a CLOSE call in ESTABLISHED</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>9</ID>
		<API>9</API>
		<Name>TCP_BASICS_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST move on to CLOSED state after receiving an ACK of the sent FIN in LAST-ACK state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>10</ID>
		<API>10</API>
		<Name>TCP_BASICS_10</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST send an ACK after receiving a FIN in FINWAIT-1 or FINWAIT-2 state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>11</ID>
		<API>11</API>
		<Name>TCP_BASICS_11</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST move on to CLOSED state from TIME-WAIT state after a timeout of 2*MSL, where TIME-WAIT is reached through FINWAIT-2 state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>12</ID>
		<API>12</API>
		<Name>TCP_BASICS_12</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST move on to CLOSED state from TIME-WAIT state after a timeout of 2*MSL, where TIME-WAIT is reached through CLOSING state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>13</ID>
		<API>13</API>
		<Name>TCP_BASICS_13</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST NOT move on to CLOSED state from TIME-WAIT state before 2*MSL time expires, where TIME-WAIT state is reached through FINWAIT-2 state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>14</ID>
		<API>14</API>
		<Name>TCP_BASICS_14</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST NOT move on to CLOSED state from TIME-WAIT state before 2*MSL time expires, where TIME-WAIT state is reached through CLOSING state</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>15</ID>
		<API>15</API>
		<Name>TCP_BASICS_17</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST support simultaneous OPEN attempts</Description>
		<Subprotocol>TCP_BASICS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>16</ID>
		<API>16</API>
		<Name>TCP_CHECKSUM_01</Name>
		<Protocol>TCP</Protocol>
		<Description>Receiver TCP MUST check the checksum in any incoming segment, and MUST acknowledge in case of no error</Description>
		<Subprotocol>TCP_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>17</ID>
		<API>17</API>
		<Name>TCP_CHECKSUM_02</Name>
		<Protocol>TCP</Protocol>
		<Description>Receiver TCP MUST check the checksum in any incoming segment, and MUST acknowledge in case of no error</Description>
		<Subprotocol>TCP_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>18</ID>
		<API>18</API>
		<Name>TCP_CHECKSUM_03</Name>
		<Protocol>TCP</Protocol>
		<Description>Sender TCP MUST generate correct checksum</Description>
		<Subprotocol>TCP_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>19</ID>
		<API>19</API>
		<Name>TCP_CHECKSUM_04</Name>
		<Protocol>TCP</Protocol>
		<Description>An ISN generator MUST be employed for selecting a 32 bit ISN that increments roughly every 4 microseconds</Description>
		<Subprotocol>TCP_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>20</ID>
		<API>20</API>
		<Name>TCP_UNACCEPTABLE_01</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST return to LISTEN state, on receiving an acceptable RST, in SYN-RCVD state</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>21</ID>
		<API>21</API>
		<Name>TCP_UNACCEPTABLE_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST NOT change state, on receiving an unacceptable RST, in SYN-RCVD state</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>22</ID>
		<API>22</API>
		<Name>TCP_UNACCEPTABLE_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST send a RST after receiving an unacceptable ACK in SYN-RCVD state</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>23</ID>
		<API>23</API>
		<Name>TCP_UNACCEPTABLE_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in ESTABLISHED state, MUST return ACK with proper SEQ and ACK numbers after recv a seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in	a synchronized state, any unacceptable segment (out of window sequence number or unacceptable acknowledgment number) must elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received, and the connection remains in the same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>24</ID>
		<API>24</API>
		<Name>TCP_UNACCEPTABLE_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in LISTEN state MUST send a RST after receiving a segment that is carrying an unacceptable ACK and remain in the same state</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>25</ID>
		<API>25</API>
		<Name>TCP_UNACCEPTABLE_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in ESTABLISHED state, MUST send an ACK indicating the correct SEQ number it 
	expects, after receiving a SYN with a SEQ number that is OTW</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>26</ID>
		<API>26</API>
		<Name>TCP_UNACCEPTABLE_07</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in LISTEN state, MUST send a RST after receiving a spurious SYN,ACK that 
	potentially corresponds to an old SYN</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>27</ID>
		<API>27</API>
		<Name>TCP_UNACCEPTABLE_08</Name>
		<Protocol>TCP</Protocol>
		<Description>If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges something not yet sent (the segment carries an unacceptable ACK), or if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection, a reset is sent. (Note : This test checks for SYN-SENT state)</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>28</ID>
		<API>28</API>
		<Name>TCP_UNACCEPTABLE_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in FINWAIT-1 state, MUST return an ACK with proper SEQ and ACK numbers after recv a seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in a synchronized state, any unacceptable segment (out of window sequence number or unacceptable acknowledgment number) must elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating 	the next sequence number expected to be received, and the connection remains in the same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>29</ID>
		<API>29</API>
		<Name>TCP_UNACCEPTABLE_10</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in FINWAIT-2 state, MUST return an ACK with proper SEQ and ACK numbers after recv
	a seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in
	a synchronized state, any unacceptable segment (out of window sequence number or
	unacceptible acknowledgment number) must elicit only an empty acknowledgment
	segment containing the current send-sequence number and an acknowledgment indicating
	the next sequence number expected to be received, and the connection remains in the
	same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>30</ID>
		<API>30</API>
		<Name>TCP_UNACCEPTABLE_11</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSING state, MUST return an ACK with proper SEQ and ACK numbers after recv a
	seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in a
	synchronized state, any unacceptable segment (out of window sequence number or
	unacceptible acknowledgment number) must elicit only an empty acknowledgment
	segment containing the current send-sequence number and an acknowledgment indicating
	the next sequence number expected to be received, and the connection remains in the
	same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>31</ID>
		<API>31</API>
		<Name>TCP_UNACCEPTABLE_12</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in LAST-ACK state, MUST return an ACK with proper SEQ and ACK numbers after recv a
	seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in a
	synchronized state, any unacceptable segment (out of window sequence number or
	unacceptible acknowledgment number) must elicit only an empty acknowledgment
	segment containing the current send-sequence number and an acknowledgment indicating
	the next sequence number expected to be received, and the connection remains in the
	same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>32</ID>
		<API>32</API>
		<Name>TCP_UNACCEPTABLE_13</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in TIME-WAIT state, MUST return an ACK with proper SEQ and ACK numbers after recv
	a seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in
	a synchronized state, any unacceptable segment (out of window sequence number or
	unacceptible acknowledgment number) must elicit only an empty acknowledgment
	segment containing the current send-sequence number and an acknowledgment indicating
	the next sequence number expected to be received, and the connection remains in the
	same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>33</ID>
		<API>33</API>
		<Name>TCP_UNACCEPTABLE_14</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSE-WAIT state, MUST return ACK with proper SEQ and ACK numbers after recv a
	seg with OTW SEQ or unacc ACK number, and remain in same state If the connection is in a
	synchronized state, any unacceptable segment (out of window sequence number or
	unacceptible acknowledgment number) must elicit only an empty acknowledgment
	segment containing the current send-sequence number and an acknowledgment indicating
	the next sequence number expected to be received, and the connection remains in the
	same state.</Description>
		<Subprotocol>TCP_UNACCEPTABLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>34</ID>
		<API>34</API>
		<Name>TCP_FLAGS_INVALID_01</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST ignore an incoming segment with RST flag in LISTEN state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>35</ID>
		<API>35</API>
		<Name>TCP_FLAGS_INVALID_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP in LISTEN state, TCP MUST send RST in response to incoming segment with ACK and remain in the same state, SEQ number of RST is taken from SEG.ACK</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>36</ID>
		<API>36</API>
		<Name>TCP_FLAGS_INVALID_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP in SYN-SENT state MUST ignore a segment carrying an unacceptable ACK and RST</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>37</ID>
		<API>37</API>
		<Name>TCP_FLAGS_INVALID_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-SENT state MUST ignore a RST control message</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>38</ID>
		<API>38</API>
		<Name>TCP_FLAGS_INVALID_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-SENT state MUST move on to CLOSED state after receiving a segment with ACK and RST and acceptable ACK number</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>39</ID>
		<API>39</API>
		<Name>TCP_FLAGS_INVALID_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-SENT state MUST drop the packet and remain in the same state after receiving a segment with neither SYN nor RST flag set</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>40</ID>
		<API>40</API>
		<Name>TCP_FLAGS_INVALID_07</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-RCVD state, MUST send ACK with next expected SEQ num on receiving any segment (without RST) with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>41</ID>
		<API>41</API>
		<Name>TCP_FLAGS_INVALID_08</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in ESTABLISHED state, MUST send an ACK with next expected SEQ number after recv any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>42</ID>
		<API>42</API>
		<Name>TCP_FLAGS_INVALID_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in FINWAIT-1 state, MUST send ACK with next expected SEQ number after receiving any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>43</ID>
		<API>43</API>
		<Name>TCP_FLAGS_INVALID_10</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in FINWAIT-2 state, MUST send ACK with next expected SEQ number after receiving any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>44</ID>
		<API>44</API>
		<Name>TCP_FLAGS_INVALID_11</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSE-WAIT state, MUST send an ACK with next expected SEQ number after recv any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>45</ID>
		<API>45</API>
		<Name>TCP_FLAGS_INVALID_12</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSING state, MUST send an ACK with next expected SEQ number after receiving any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>46</ID>
		<API>46</API>
		<Name>TCP_FLAGS_INVALID_13</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in LAST-ACK state, MUST send an ACK with next expected SEQ number after receiving any segment with OTW SEQ number and remain in the same state</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>47</ID>
		<API>47</API>
		<Name>TCP_FLAGS_INVALID_15</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in any state other than CLOSED, SYN-SENT and LISTEN states, MUST ignore a RST segment with OTW SEQ number</Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>48</ID>
		<API>48</API>
		<Name>TCP_FLAGS_PROCESSING_01</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-RCVD state, reached through active OPEN, MUST inform \"connection refused\" to application on recv a RST</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>49</ID>
		<API>49</API>
		<Name>TCP_FLAGS_PROCESSING_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYNC-RCVD, ESTABLISHED,  FINWAIT-1, FINWAIT-2, CLOSE-WAIT states, MUST return to CLOSED state on RESET</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>50</ID>
		<API>50</API>
		<Name>TCP_FLAGS_PROCESSING_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSING, LAST-ACK state, MUST return to CLOSED state on receiving a RST</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>51</ID>
		<API>51</API>
		<Name>TCP_FLAGS_PROCESSING_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in TIME-WAIT state, MUST return to CLOSED state on receiving a RST  
		(Note: Test case will be executes only if DUT does not support RFC 1337 based Time Wait Assassination Avoidance)</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>52</ID>
		<API>52</API>
		<Name>TCP_FLAGS_PROCESSING_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in SYN-RCVD state, MUST send a reset and go to CLOSED state, on recv a seg with SYN in window</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>53</ID>
		<API>53</API>
		<Name>TCP_FLAGS_PROCESSING_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in TIME-WAIT state, MUST acknowledge a retransmitted FIN and restart the 2*MSL time-out</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>54</ID>
		<API>54</API>
		<Name>TCP_FLAGS_PROCESSING_07</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSE-WAIT, CLOSING, LAST-ACK or TIME-WAIT state, MUST ignore any segment with only URG flag set</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>55</ID>
		<API>55</API>
		<Name>TCP_FLAGS_PROCESSING_08</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSED, LISTEN or SYN-SENT state, MUST not process a FIN</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>56</ID>
		<API>56</API>
		<Name>TCP_FLAGS_PROCESSING_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in CLOSE-WAIT, CLOSING or LAST-ACK state, MUST not change state after receiving a FIN</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>57</ID>
		<API>57</API>
		<Name>TCP_FLAGS_PROCESSING_10</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in ESTABLISHED state, SHOULD piggyback acknowledgement with a segment being transmitted (whenever possible) without incurring undue delay</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>58</ID>
		<API>58</API>
		<Name>TCP_FLAGS_PROCESSING_11</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP, in ESTABLISHED state, MUST ignore a duplicate ACK</Description>
		<Subprotocol>TCP_FLAGS_PROCESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>59</ID>
		<API>59</API>
		<Name>TCP_MSS_OPTIONS_01</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be prepared to handle an illegal option length for MSS, in a SYN segment, without crashing</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>60</ID>
		<API>60</API>
		<Name>TCP_MSS_OPTIONS_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be able to receive No Operation and End of Options List options in SYN  segment</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>61</ID>
		<API>61</API>
		<Name>TCP_MSS_OPTIONS_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST ignore without error any TCP option it does not implement</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>62</ID>
		<API>62</API>
		<Name>TCP_MSS_OPTIONS_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be prepared to handle an illegal option length for MSS, in a SYN-ACK segment, without crashing</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>63</ID>
		<API>63</API>
		<Name>TCP_MSS_OPTIONS_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be able to receive MSS option in SYN segment and calculate the effective send segment size appropriately</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>64</ID>
		<API>64</API>
		<Name>TCP_MSS_OPTIONS_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST be able to receive MSS option in SYN,ACK segment and calculate the effective send segment size appropriately</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>65</ID>
		<API>65</API>
		<Name>TCP_MSS_OPTIONS_10</Name>
		<Protocol>TCP</Protocol>
		<Description>If an MSS option is not received at connection setup, TCP MUST assume a default send MSS of 536</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>66</ID>
		<API>66</API>
		<Name>TCP_MSS_OPTIONS_11</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST implement sending the MSS option</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>67</ID>
		<API>67</API>
		<Name>TCP_MSS_OPTIONS_12</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD send MSS option in every SYN segment when its receive MSS differs from the default 536</Description>
		<Subprotocol>TCP_MSS_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>68</ID>
		<API>68</API>
		<Name>TCP_OUT_OF_ORDER_01</Name>
		<Protocol>TCP</Protocol>
		<Description>A full-sized segment MUST be acknowledged within a time of 0.5 sec</Description>
		<Subprotocol>TCP_OUT_OF_ORDER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>69</ID>
		<API>69</API>
		<Name>TCP_OUT_OF_ORDER_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD implement a delayed ACK, but the delay MUST be less than 0.5 sec</Description>
		<Subprotocol>TCP_OUT_OF_ORDER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>70</ID>
		<API>70</API>
		<Name>TCP_OUT_OF_ORDER_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD be capable of queuing out-of-order segments</Description>
		<Subprotocol>TCP_OUT_OF_ORDER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>71</ID>
		<API>71</API>
		<Name>TCP_OUT_OF_ORDER_05</Name>
		<Protocol>TCP</Protocol>
		<Description>In a stream of full-sized segments there SHOULD be an ACK for at least every second segment</Description>
		<Subprotocol>TCP_OUT_OF_ORDER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>72</ID>
		<API>72</API>
		<Name>TCP_RETRANSMISSION_TO_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST follow the Karn's algorithm</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>73</ID>
		<API>73</API>
		<Name>TCP_RETRANSMISSION_TO_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST include \"exponential backoff\" (check that it increases) for successive RTO values for sending data segments</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>74</ID>
		<API>74</API>
		<Name>TCP_RETRANSMISSION_TO_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST include \"exponential backoff\" (check that it increases) for successive RTO values for sending SYN segments</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>75</ID>
		<API>75</API>
		<Name>TCP_RETRANSMISSION_TO_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD use RTO = 1 sec initially (RFC 6298)</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>76</ID>
		<API>76</API>
		<Name>TCP_RETRANSMISSION_TO_08</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD use an upper bound of 2*MSL of RTO for data segments</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>77</ID>
		<API>77</API>
		<Name>TCP_RETRANSMISSION_TO_09</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD use an upper bound of 2*MSL of RTO for SYN segment</Description>
		<Subprotocol>TCP_RETRANSMISSION_TO</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>78</ID>
		<API>78</API>
		<Name>UDP_MessageFormat_02</Name>
		<Protocol>UDP</Protocol>
		<Description>Ensure that when the DUT receives a UDP packet containing a well-formed Header containing a Source Port field  containing a Destination Port indicating a value equal to the DUT’s UDP port containing a Length field indicating a valid value equal to the size of the sent datagram containing a Checksum field indicating a value equal to the calculatedUDPChecksum by the DUT then the DUT accepts the UDP packet.</Description>
		<Subprotocol>UDP_MessageFormat</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>79</ID>
		<API>79</API>
		<Name>UDP_DatagramLength_01</Name>
		<Protocol>UDP</Protocol>
		<Description>Ensure that when the DUT receives a truncated UDP packet (a packet with the length field smaller than the actual size of the data coming from the Ethernet frame) then the DUT discards the UDP packet.</Description>
		<Subprotocol>UDP_DatagramLength</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>80</ID>
		<API>80</API>
		<Name>UDP_Padding_02</Name>
		<Protocol>UDP</Protocol>
		<Description>Ensure that when the DUT is requested to generate a UDP packet with an even payload size then the DUT generates a UDP packet containing Data indicating value of the received even with no padding bytes</Description>
		<Subprotocol>UDP_Padding</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>81</ID>
		<API>81</API>
		<Name>UDP_FIELDS_01</Name>
		<Protocol>UDP</Protocol>
		<Description>Source Port is an optional field, when meaningful, it indicates the port of the sending  process, and may be assumed to be the port to which a reply should be addressed in the absence of any other information. A user interface should allow the creation of new receive ports [Note: In this test, we verify that application can specify source port]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>82</ID>
		<API>82</API>
		<Name>UDP_FIELDS_02</Name>
		<Protocol>UDP</Protocol>
		<Description>Source Port is an optional field, when meaningful, it indicates the port of the sending Source Port is an optional field, when meaningful, it indicates the port of the sending  process, and may be assumed to be the port to which a reply should be addressed in the absence of any other information. [Note: In this test, we verify that a UDP messages must include a destination port]  process, and may be assumed to be the port to which a reply should be addressed in the absence of any other information. [Note: In this test, we verify that a UDP messages must include a destination port]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>83</ID>
		<API>83</API>
		<Name>UDP_FIELDS_03</Name>
		<Protocol>UDP</Protocol>
		<Description>Source Port is an optional field, when meaningful, it indicates the port of the sending process, and may be assumed to be the port to which a reply should be addressed in the absence of any other information. If not used, a value of zero is inserted. [Note: In this test, we verify that using the value 0 for UDP Source Port is valid and DUT accepts such a Message]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>84</ID>
		<API>84</API>
		<Name>UDP_FIELDS_04</Name>
		<Protocol>UDP</Protocol>
		<Description>Destination Port has a meaning within the context of a particular internet destination address. [Note: In this test, we verify that DUT can send UDP message at same destination port to more than one differrent IP addresses.]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>85</ID>
		<API>85</API>
		<Name>UDP_FIELDS_05</Name>
		<Protocol>UDP</Protocol>
		<Description>Destination Port has a meaning within the context of a particular internet destination address. [Note: In this test, we verify that DUT can receive send UDP message at same destination port to more than one differrent IP addresses.]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>86</ID>
		<API>86</API>
		<Name>UDP_FIELDS_06</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: In this test, we configure DUT to send  size of data so that the length in Header is</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>87</ID>
		<API>87</API>
		<Name>UDP_FIELDS_07</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: In this test, we configure DUT to send 0 (zero) size of data so that the length in Header is 8(UDP Header Size)) bytes]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>88</ID>
		<API>88</API>
		<Name>UDP_FIELDS_08</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: Check that the DUT discards the received datagram in case the total length of the datagram is less than 8 bytes]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>89</ID>
		<API>89</API>
		<Name>UDP_FIELDS_09</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: Check that the DUT discards the received datagram in case the total length of the datagram is zero (‘0’)]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>90</ID>
		<API>90</API>
		<Name>UDP_FIELDS_10</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: Check that the DUT discards the received datagram in case the length value in the header is greater than the actual length of the datagram]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>91</ID>
		<API>91</API>
		<Name>UDP_FIELDS_12</Name>
		<Protocol>UDP</Protocol>
		<Description>Length is the length in octets of this user datagram including this header and the data.
		[Note: Check that the DUT accepts the received datagram in case the length value in the header is set to the maximum allowed value.
		- IPv4: 65,507 bytes  (65,535 − 8 byte UDP header − 20 byte IP header)
		- IPv6: 65,535 bytes]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>92</ID>
		<API>92</API>
		<Name>UDP_FIELDS_13</Name>
		<Protocol>UDP</Protocol>
		<Description>Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, the UDP header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets. [Note: In this test, we verify that DUT calculates UDP checksum correctly. While calculating UDP checksum the padded byte is needed to be considered.]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>93</ID>
		<API>93</API>
		<Name>UDP_FIELDS_14</Name>
		<Protocol>UDP</Protocol>
		<Description>Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, the UDP header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets. [Note: In this test, we verify that DUT calculates UDP checksum correctly. While calculating UDP checksum the padded byte is not required.]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>94</ID>
		<API>94</API>
		<Name>UDP_FIELDS_15</Name>
		<Protocol>UDP</Protocol>
		<Description>If a UDP datagram is received with a checksum that is non-zero and invalid, UDP MUST silently discard the datagram. [Note: In this test, we verify that DUT will not accept UDP message with incorrect checksum]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>95</ID>
		<API>95</API>
		<Name>UDP_FIELDS_16</Name>
		<Protocol>UDP</Protocol>
		<Description>An all zero transmitted checksum value means that the transmitter generated no checksum (for debugging or for higher level protocols that don't care). An application MAY optionally be able to control whether a UDP checksum will be generated, but it MUST default to checksumming on. [Note: In this test, we verify that DUT accepts UDP datagram with zero checksum]</Description>
		<Subprotocol>UDP_FIELDS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>96</ID>
		<API>96</API>
		<Name>UDP_USER_INTERFACE_01</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that user
		interface allows creation of new receive ports. This test is only ran when  is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>97</ID>
		<API>97</API>
		<Name>UDP_USER_INTERFACE_02</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that receive operations on the receive ports return the data octets correctly. This test is only ran when  is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>98</ID>
		<API>98</API>
		<Name>UDP_USER_INTERFACE_03</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that receive operations on the receive ports return the source port correctly. This test is only ran when  is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>99</ID>
		<API>99</API>
		<Name>UDP_USER_INTERFACE_04</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that receive operations on the receive ports return the source address correctly. This test is only ran when is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>100</ID>
		<API>100</API>
		<Name>UDP_USER_INTERFACE_05</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that an
		operation that allows a datagram to be sent, specifies the source port to be sent. This test is only ran when  is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>101</ID>
		<API>101</API>
		<Name>UDP_USER_INTERFACE_06</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that an
		operation that allows a datagram to be sent, specifies the destination port to be sent. This test is only ran when  is TRUE]</Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>102</ID>
		<API>102</API>
		<Name>UDP_USER_INTERFACE_07</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that an
		operation that allows a datagram to be sent, specifies the source address to be sent. This test is only ran when  is TRUE] </Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>103</ID>
		<API>103</API>
		<Name>UDP_USER_INTERFACE_08</Name>
		<Protocol>UDP</Protocol>
		<Description>A user interface should allow the creation of new receive ports, receive operations on the receive ports that return the data octets and an indication of source port and source
		address, and an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent. [Note: In this test, we verify that an
		operation that allows a datagram to be sent, specifies the destination address to be sent. This test is only ran when  is TRUE] </Description>
		<Subprotocol>UDP_USER_INTERFACE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>104</ID>
		<API>104</API>
		<Name>UDP_INTRODUCTION_01</Name>
		<Protocol>UDP</Protocol>
		<Description>If a datagram arrives addressed to a UDP port for which there is no pending LISTEN call, UDP SHOULD send an ICMP Port Unreachable message</Description>
		<Subprotocol>UDP_INTRODUCTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>105</ID>
		<API>105</API>
		<Name>UDP_INTRODUCTION_02</Name>
		<Protocol>UDP</Protocol>
		<Description>UDP is used by applications that do not require the level of service of TCP or that wish to use communications services (e.g., multicast or broadcast delivery) not available from TCP.
		[Note: In this test we verify that DUT will deny UDP message with  multicast destination Address. Note: this test inverts the RFC requirement due to security negotiations]</Description>
		<Subprotocol>UDP_INTRODUCTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>106</ID>
		<API>106</API>
		<Name>UDP_INTRODUCTION_03</Name>
		<Protocol>UDP</Protocol>
		<Description>If a datagram arrives addressed to a UDP port for which there is no pending LISTEN call, UDP SHOULD send an ICMP Port Unreachable message</Description>
		<Subprotocol>UDP_INTRODUCTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>107</ID>
		<API>107</API>
		<Name>UDP_INVALID_ADDRESSES_01</Name>
		<Protocol>UDP</Protocol>
		<Description>A UDP datagram received with an invalid IP source address (e.g., a broadcast or multicast address) must be discarded by UDP or by the IP layer (see Section 3.2.1.3). [Note: In this
		test, we verify UDP Message with multicast address as source address. ] </Description>
		<Subprotocol>UDP_INVALID_ADDRESSES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>108</ID>
		<API>108</API>
		<Name>UDP_INVALID_ADDRESSES_02</Name>
		<Protocol>UDP</Protocol>
		<Description>A UDP datagram received with an invalid IP source address (e.g., a broadcast or multicast address) must be discarded by UDP or by the IP layer (see Section 3.2.1.3). [Note: In this
		test, we verify UDP Message with broadcast address as source address. ]</Description>
		<Subprotocol>UDP_INVALID_ADDRESSES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>109</ID>
		<API>109</API>
		<Name>ARP_01_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. (Note: Here DUT is configured to add a static entry [HOST-1-IP, MAC-ADDR1] in its ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>110</ID>
		<API>110</API>
		<Name>ARP_02_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. (Note: Here DUT is configured to add a static entry [HOST-1-IP, MAC-ADDR1] in its ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects  that DUT will send an ICMP Echo Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>111</ID>
		<API>111</API>
		<Name>ARP_03_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>112</ID>
		<API>112</API>
		<Name>ARP_04_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>113</ID>
		<API>113</API>
		<Name>ARP_05_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>114</ID>
		<API>114</API>
		<Name>ARP_06_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>115</ID>
		<API>115</API>
		<Name>ARP_07_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>116</ID>
		<API>116</API>
		<Name>ARP_08_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>117</ID>
		<API>117</API>
		<Name>ARP_09_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module sets the ar$pro to the protocol type that is being  resolved.</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>118</ID>
		<API>118</API>
		<Name>ARP_10_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>119</ID>
		<API>119</API>
		<Name>ARP_11_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>120</ID>
		<API>120</API>
		<Name>ARP_12_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>121</ID>
		<API>121</API>
		<Name>ARP_13_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>122</ID>
		<API>122</API>
		<Name>ARP_14_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. 
		(Note: The objective of the test case is to validate the ARP Learning mechanism on ARP requests. .Here TESTER sends an ARP Request to DUT so that an entry [HOST-1-IP, MACADDR1] gets added in DUT's ARP cache. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will NOT send any ARP Request.)</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>123</ID>
		<API>123</API>
		<Name>ARP_15_Packet_Generation</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module sets the ar$tpa with the protocol address of the machine that is trying to be accessed</Description>
		<Subprotocol>ARP_Packet_Generation</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	

	<Test>
		<ID>124</ID>
		<API>124</API>
		<Name>ARP_16_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module does not set ar$tha to anything in particular, because it is  this value that it is trying to determine. (Note: In this test TESTER sends an ARP Request with ARP Target Hardware Address set to all zeroes, and, expects that DUT will send an ARP Response after receiving the ARP Request)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>125</ID>
		<API>125</API>
		<Name>ARP_17_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module does not set ar$tha to anything in particular, because it is  this value that it is trying to determine. (Note: In this test TESTER sends an ARP Request with ARP Target Hardware Address set to Ethernet Broadcast Address, and, expects that DUT will send an ARP Response after receiving the ARP Request)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>126</ID>
		<API>126</API>
		<Name>ARP_18_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module does not set ar$tha to anything in particular, because it is  this value that it is trying to determine. (Note: In this test TESTER sends an ARP Request with ARP Target Hardware Address set to an arbitrary value, and, expects that DUT will send an ARP Response after receiving the ARP Request)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>
	
	<Test>
		<ID>127</ID>
		<API>127</API>
		<Name>ARP_19_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>The Address Resolution module tries to find the [protocol type, target protocol address] pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet.</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>128</ID>
		<API>128</API>
		<Name>ARP_20_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>129</ID>
		<API>129</API>
		<Name>ARP_21_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>130</ID>
		<API>130</API>
		<Name>ARP_22_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.) </Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>131</ID>
		<API>131</API>
		<Name>ARP_26_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I speak the protocol in ar$pro? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with protocol type field set to type IP. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>132</ID>
		<API>132</API>
		<Name>ARP_27_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I speak the protocol in ar$pro? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with protocol type field set to an unknown protocol type value. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should NOT send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>133</ID>
		<API>133</API>
		<Name>ARP_28_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I speak the protocol in ar$pro? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries.TESTER then sends an ARP Response with protocol type field set to Unknown Protocol value. All the other fields in the ARP Response Packet are set to their correct values. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will send an ARP Request)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>134</ID>
		<API>134</API>
		<Name>ARP_32_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which
		goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet. 
		Merge_flag := false If the pair</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>135</ID>
		<API>135</API>
		<Name>ARP_33_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which 
		goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet.
		Merge_flag := false If the pair</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>136</ID>
		<API>136</API>
		<Name>ARP_34_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet. Merge_flag := false If the pair</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>137</ID>
		<API>137</API>
		<Name>ARP_35_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet. Merge_flag := false If the pair</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>138</ID>
		<API>138</API>
		<Name>ARP_36_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet ?Am I the target protocol address? (Note: In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with target protocol address field set to . All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>139</ID>
		<API>139</API>
		<Name>ARP_37_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet ?Am I the target protocol address? (Note: In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with target protocol address field set to an IP First unused address value. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should NOT send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>140</ID>
		<API>140</API>
		<Name>ARP_38_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following, Negative conditionals indicate an end of processing and a discarding of the packet ?Am I the target protocol address? (Note: In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Response with target protocol address field set to IP First unused address value. All the other fields in the ARP Response Packet are set to their correct values. TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will send an ARP Request)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>141</ID>
		<API>141</API>
		<Name>ARP_39_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet. If Merge_flag is false, add the triplet . TESTER then causes DUT to send an ICMP Echo Request and expects that DUT will send an ICMP Echo Request with Ethernet Destination Address set to</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>142</ID>
		<API>142</API>
		<Name>ARP_40_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>143</ID>
		<API>143</API>
		<Name>ARP_41_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>144</ID>
		<API>144</API>
		<Name>ARP_42_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>145</ID>
		<API>145</API>
		<Name>ARP_43_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>146</ID>
		<API>146</API>
		<Name>ARP_44_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>147</ID>
		<API>147</API>
		<Name>ARP_45_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>148</ID>
		<API>148</API>
		<Name>ARP_46_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module which goes through an algorithm similar to the following:Negative conditionals indicate an end of processing and a discarding of the packet ?Do I have the hardware type in ar$hrd? (Note:In this test TESTER is configuring DUT to clear its ARP Cache entries. TESTER then sends an ARP Request with hardware type field set to Ethernet. All the other fields in the ARP Request Packet are set to their correct values. It then expects that DUT should send an ARP Response.)</Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>149</ID>
		<API>149</API>
		<Name>ARP_47_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description></Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>150</ID>
		<API>150</API>
		<Name>ARP_48_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description></Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>151</ID>
		<API>151</API>
		<Name>ARP_49_Packet_Reception</Name>
		<Protocol>ARP</Protocol>
		<Description></Description>
		<Subprotocol>ARP_Packet_Reception</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>152</ID>
		<API>152</API>
		<Name>ICMPv4_ERROR_02</Name>
		<Protocol>ICMP</Protocol>
		<Description>Also ICMP messages are only sent about errors in handling fragment zero of fragmented datagrams. (Note: This tests that ICMP error message is sent on receiving the fragment having Fragment Offset field set to zero. This test is ran when is TRUE)</Description>
		<Subprotocol>ICMPv4_ERROR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>153</ID>
		<API>153</API>
		<Name>ICMPv4_ERROR_03</Name>
		<Protocol>ICMP</Protocol>
		<Description></Description>
		<Subprotocol>ICMPv4_ERROR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>154</ID>
		<API>154</API>
		<Name>ICMPv4_ERROR_04</Name>
		<Protocol>ICMP</Protocol>
		<Description>An ICMP error message MUST NOT be sent as the result of receiving a datagram destined to an IP broadcast. (Note: This test is ran when is TRUE)</Description>
		<Subprotocol>ICMPv4_ERROR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>155</ID>
		<API>155</API>
		<Name>ICMPv4_ERROR_05</Name>
		<Protocol>ICMP</Protocol>
		<Description>If an ICMP message of unknown type is received, it MUST be silently discarded.</Description>
		<Subprotocol>ICMPv4_ERROR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>156</ID>
		<API>156</API>
		<Name>ICMPv4_TYPE_04</Name>
		<Protocol>ICMP</Protocol>
		<Description>If fragment zero is not available then no time exceeded need be sent at all.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>157</ID>
		<API>157</API>
		<Name>ICMPv4_TYPE_05</Name>
		<Protocol>ICMP</Protocol>
		<Description>If the gateway or host processing a datagram finds a problem with the header parameters such that it cannot complete processing the datagram it must discard the datagram. (Note: This test is ran when is TRUE)</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>158</ID>
		<API>158</API>
		<Name>ICMPv4_TYPE_08</Name>
		<Protocol>ICMP</Protocol>
		<Description>The data received in the echo message must be returned in the echo reply message.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>159</ID>
		<API>159</API>
		<Name>ICMPv4_TYPE_09</Name>
		<Protocol>ICMP</Protocol>
		<Description>The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>160</ID>
		<API>160</API>
		<Name>ICMPv4_TYPE_10</Name>
		<Protocol>ICMP</Protocol>
		<Description>The checksum is the 16-bit one's complement of the one's complement sum of the ICMP message starting with the ICMP Type. For computing the checksum, the checksum field should be zero. If the total length is odd, the received data is padded with one octet of zeros for computing the checksum. (Note: This tests that a node does not send ICMP Echo Reply if ICMP Checksum is incorrect).</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>161</ID>
		<API>161</API>
		<Name>ICMPv4_TYPE_11</Name>
		<Protocol>ICMP</Protocol>
		<Description>The data received (a timestamp) in the message is returned in the reply together with  an additional timestamp.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>162</ID>
		<API>162</API>
		<Name>ICMPv4_TYPE_12</Name>
		<Protocol>ICMP</Protocol>
		<Description>The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>163</ID>
		<API>163</API>
		<Name>ICMPv4_TYPE_16</Name>
		<Protocol>ICMP</Protocol>
		<Description>A host SHOULD NOT implement these messages. [Note: referring to Information  Request or Information Reply Message]</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>164</ID>
		<API>164</API>
		<Name>ICMPv4_TYPE_18</Name>
		<Protocol>ICMP</Protocol>
		<Description>A host must respond to an IPv4 Packet containnig an , by sending a Destination Unreachable message including the Protcol Unreachable code.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>165</ID>
		<API>165</API>
		<Name>ICMPv4_TYPE_22</Name>
		<Protocol>ICMP</Protocol>
		<Description>A host must respond to all ICMP Echo Requests sent to it, by sending an ICMP Echo  Reply back to the sender of ICMP Echo Request.</Description>
		<Subprotocol>ICMPv4_TYPE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>166</ID>
		<API>166</API>
		<Name>IPv4_HEADER_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT is requested to generate an IPv4 packet, then the DUT generates an IPv4 Packet containing an IPv4 Header containing a Total Length indicating a value greater than or equal to 20.</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>167</ID>
		<API>167</API>
		<Name>IPv4_HEADER_02</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Header Length indicating a value less than 20, then the DUT discards the IPv4 Packet silently.</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>168</ID>
		<API>168</API>
		<Name>IPv4_HEADER_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT is requested to generate an IPv4 packet, then the DUT sends an IPv4 Packet containing an IPv4 Header containing a Source Address indicating one of its defined IPv4 addresses.</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>169</ID>
		<API>169</API>
		<Name>IPv4_HEADER_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Destination Address
		indicating a value different from the DUT’s IPv4 address and is not a Broadcast or Multicast address, then the DUT discards the IPv4 Packet silently.</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>170</ID>
		<API>170</API>
		<Name>IPv4_HEADER_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>All hosts must be prepared to accept datagrams of up to 576 octets.</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>171</ID>
		<API>171</API>
		<Name>IPv4_HEADER_08</Name>
		<Protocol>IPv4</Protocol>
		<Description>Internet Header Length is the length of the internet header in 32 bit words, and thus
		points to the beginning of the data.  Note that the minimum value for a correct header is 5.
		(Note: Tests that DUT discards a packet with total length smaller than implied by IHL value)</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>172</ID>
		<API>172</API>
		<Name>IPv4_HEADER_09</Name>
		<Protocol>IPv4</Protocol>
		<Description>Total Length is the length of the datagram, measured in octets, including internet header
		and data. (Note: Tests that DUT discards a packet with total length bigger than the actual
		transmitted data)</Description>
		<Subprotocol>IPv4_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>173</ID>
		<API>173</API>
		<Name>IPv4_CHECKSUM_02</Name>
		<Protocol>IPv4</Protocol>
		<Description>If the header checksum fails, the internet datagram is discarded at once by the entity which detects the error.</Description>
		<Subprotocol>IPv4_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>174</ID>
		<API>174</API>
		<Name>IPv4_CHECKSUM_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>The checksum field is the 16 bit one's complement of the one's complement sum of all 16
		bit words in the header. For purposes of computing the checksum, the value of the
		checksum field is zero. (Note: Here we send an Echo Request with checksum calculated
		according to rfc. DUT receives this Echo Request, verifies the Echo Request and then sends
		Echo Reply. We then verify that DUT uses the checksum calculation method according to
		rfc)</Description>
		<Subprotocol>IPv4_CHECKSUM</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>175</ID>
		<API>175</API>
		<Name>IPv4_TTL_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>A host MUST NOT send a datagram with a Time-to-Live (TTL) value of zero.</Description>
		<Subprotocol>IPv4_TTL</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>176</ID>
		<API>176</API>
		<Name>IPv4_TTL_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>A host MUST NOT discard a datagram just because it was received with TTL less than 2.</Description>
		<Subprotocol>IPv4_TTL</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>177</ID>
		<API>177</API>
		<Name>IPv4_VERSION_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Version indicating a value of 4,then the DUT accepts the IPv4 Packet.</Description>
		<Subprotocol>IPv4_VERSION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>178</ID>
		<API>178</API>
		<Name>IPv4_VERSION_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Version indicating a value of 4,then the DUT accepts the IPv4 Packet.</Description>
		<Subprotocol>IPv4_VERSION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>179</ID>
		<API>179</API>
		<Name>IPv4_VERSION_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Version indicating a value of 4,then the DUT accepts the IPv4 Packet.</Description>
		<Subprotocol>IPv4_VERSION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>180</ID>
		<API>180</API>
		<Name>IPv4_ADDRESSING_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Destination Address indicating a value of Limited Broadcast,then the DUT accepts the IPv4 Packet.</Description>
		<Subprotocol>IPv4_ADDRESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>181</ID>
		<API>181</API>
		<Name>IPv4_ADDRESSING_02</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Destination Address indicating a value of Directed Broadcast,then the DUT discards the IPv4 Packet silently.</Description>
		<Subprotocol>IPv4_ADDRESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>182</ID>
		<API>182</API>
		<Name>IPv4_ADDRESSING_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing a Destination Address indicating a value of Loop Back,then the DUT discards the IPv4 packet silently.</Description>
		<Subprotocol>IPv4_ADDRESSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>183</ID>
		<API>183</API>
		<Name>IPv4_FRAGMENTS_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>To assemble the fragments of an internet datagram, an internet protocol module (for
		example at a destination host) combines internet datagrams that all have the same value
		for the four fields: identification, source, destination, and protocol.</Description>
		<Subprotocol>IPv4_FRAGMENTS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>184</ID>
		<API>184</API>
		<Name>IPv4_FRAGMENTS_02</Name>
		<Protocol>IPv4</Protocol>
		<Description>To assemble the fragments of an internet datagram, an internet protocol module (for 
		example at a destination host) combines internet datagrams that all have the same value
		for the four fields: identification, source, destination, and protocol. (Note: This test verifies
		that IP module does not assemble the fragments if identification is different).</Description>
		<Subprotocol>IPv4_FRAGMENTS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>185</ID>
		<API>185</API>
		<Name>IPv4_FRAGMENTS_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>To assemble the fragments of an internet datagram, an internet protocol module (for 
		example at a destination host) combines internet datagrams that all have the same valufor the four fields: identification, source, destination, and protocol. 
		(Note: This test verifithat IP module does not assemble the fragments if source is different).</Description>
		<Subprotocol>IPv4_FRAGMENTS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>186</ID>
		<API>186</API>
		<Name>IPv4_FRAGMENTS_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>To assemble the fragments of an internet datagram, an internet protocol module (for 
		example at a destination host) combines internet datagrams that all have the same value
		for the four fields: identification, source, destination, and protocol. (Note: This test verifies
		that IP module does not assemble the fragments if protocol is different).</Description>
		<Subprotocol>IPv4_FRAGMENTS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>187</ID>
		<API>187</API>
		<Name>IPv4_FRAGMENTS_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>The fragmentation strategy is designed so than an unfragmented datagram has all zero
		fragmentation information (MF = 0, fragment offset = 0).</Description>
		<Subprotocol>IPv4_FRAGMENTS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>188</ID>
		<API>188</API>
		<Name>IPv4_REASSEMBLY_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives a series of unordered IPv4 Fragments of a large IPv4 packet 
		then the DUT reassembles and accept the IPv4 packet.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>189</ID>
		<API>189</API>
		<Name>IPv4_REASSEMBLY_06</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives a series of IPv4 Fragments of a large IPv4 packet containing an IPv4 Header containing an Offset
		indicating a value different than 0 but with correct increment then the DUT does not reassemble and accept the IPv4 packet.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>190</ID>
		<API>190</API>
		<Name>IPv4_REASSEMBLY_07</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives a series of IPv4 Fragments of a large IPv4 packet including the first and the last fragment but missing some in between then the DUT does not reassemble and accept the IPv4 packet. </Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>191</ID>
		<API>191</API>
		<Name>IPv4_REASSEMBLY_09</Name>
		<Protocol>IPv4</Protocol>
		<Description>Ensure that when the DUT receives an IPv4 packet containing an IPv4 Header containing Flags and containing a MF flag indicating that there are more fragments coming: MF = 1, then the DUT discards the IPv4 Packet silently.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>192</ID>
		<API>192</API>
		<Name>IPv4_REASSEMBLY_10</Name>
		<Protocol>IPv4</Protocol>
		<Description>The current recommendation for the initial timer setting is 15 seconds.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>193</ID>
		<API>193</API>
		<Name>IPv4_REASSEMBLY_11</Name>
		<Protocol>IPv4</Protocol>
		<Description>The initial setting of the timer is a lower bound on the reassembly waiting time. This is
		because the waiting time will be increased if the Time to Live in the arriving fragment is
		greater than the current timer value.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>194</ID>
		<API>194</API>
		<Name>IPv4_REASSEMBLY_12</Name>
		<Protocol>IPv4</Protocol>
		<Description>
		The initial setting of the timer is a lower bound on the reassembly waiting time. The
		waiting time will not be decreased if it is less the Time to Live in the arriving fragment.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>195</ID>
		<API>195</API>
		<Name>IPv4_REASSEMBLY_13</Name>
		<Protocol>IPv4</Protocol>
		<Description>In the case that two or more fragments contain the same data either identically or
		through a partial overlap, this procedure will use the more recently arrived copy in the
		data buffer and datagram delivered.</Description>
		<Subprotocol>IPv4_REASSEMBLY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>196</ID>
		<API>196</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>The first 256 and last 256 addresses in the 169.254/16 prefix are reserved for future use and MUST NOT be selected by a host using this dynamic configuration mechanism.</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>197</ID>
		<API>197</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>A host probes to see if an address is already in use by broadcasting an ARP Request for the desired address. (Note: this is an ARP Probe Request)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>198</ID>
		<API>198</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>The client MUST fill in the sender hardware address field of the ARP Request with the
		hardware address of the interface through which it is sending the packet. (Note: This holds
		true for all kinds of ARP frames: Request, Response, Probe)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>199</ID>
		<API>199</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_06</Name>
		<Protocol>IPv4</Protocol>
		<Description>The sender IP address field MUST be set to all zeroes. (Note: this is testing for the ARP Probe frame).</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>200</ID>
		<API>200</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_07</Name>
		<Protocol>IPv4</Protocol>
		<Description>The target hardware address field is ignored and SHOULD be set to all zeroes.</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>201</ID>
		<API>201</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_08</Name>
		<Protocol>IPv4</Protocol>
		<Description>The target IP address field MUST be set to the address being probed.</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>202</ID>
		<API>202</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_09</Name>
		<Protocol>IPv4</Protocol>
		<Description>When ready to begin probing, the host should then wait for a random time interval selected
		uniformly in the range zero to PROBE_WAIT seconds, and should then send PROBE_NUM
		probe packets, each of these probe packets spaced randomly, PROBE_MIN to PROBE_MAX
		seconds apart. (Note : Here TESTER is verifying that the number of PROBES received is equal
		to PROBE_NUM)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>203</ID>
		<API>203</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_10</Name>
		<Protocol>IPv4</Protocol>
		<Description>When ready to begin probing, the host should then wait for a random time interval selected
		uniformly in the range zero to PROBE_WAIT seconds, and should then send PROBE_NUM
		probe packets, each of these probe packets spaced randomly, PROBE_MIN to PROBE_MAX
		seconds apart. (Note : Here TESTER is verifying that the time gap between consecutive
		probes falls in the range.Tolerance is 50 milliseconds).</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>204</ID>
		<API>204</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_11</Name>
		<Protocol>IPv4</Protocol>
		<Description>If during this period, from the beginning of the probing process until ANNOUNCE_WAIT
		seconds after the last probe packet is sent, the host receives any ARP packet (Request *or*
		Reply) on the interface where the probe is being performed where the packet's 'sender IP
		address' is the address being probed for, then the host MUST treat this address as being in
		use by some other host, and MUST select a new pseudo-random address and repeat the
		process. (Note : Here TESTER is sending a conflicting ARP request packet with sender IP
		address equal to the link-local probed address and verifies that DUT sends another ARP
		Probe with a different link-local probe address)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>205</ID>
		<API>205</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_12</Name>
		<Protocol>IPv4</Protocol>
		<Description>If during this period, from the beginning of the probing process until ANNOUNCE_WAIT
		seconds after the last probe packet is sent, the host receives any ARP packet (Request *or*
		Reply) on the interface where the probe is being performed where the packet's 'sender IP
		address' is the address being probed for, then the host MUST treat this address as being in
		use by some other host, and MUST select a new pseudo-random address and repeat the
		process. (Note : Here TESTER is sending a conflicting ARP Response packet with sender IP
		address equal to the link-local probed address and verifies that DUT sends another ARP
		Probe with a different link-local probe address)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>206</ID>
		<API>206</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_13</Name>
		<Protocol>IPv4</Protocol>
		<Description>In addition, if during this period the host receives any ARP Probe where the packet's 'target 
		IP address' is the address being probed for, and the packet's 'sender hardware address' is
		not the hardware address of the interface the host is attempting to configure, then the host
		MUST similarly treat this as an address conflict and select a new address as above.</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>207</ID>
		<API>207</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_14</Name>
		<Protocol>IPv4</Protocol>
		<Description>If the number of conflicts exceeds MAX_CONFLICTS then the host MUST limit the rate at
		which it probes for new addresses to no more than one new address per
		RATE_LIMIT_INTERVAL. (Note : Here TESTER checks that if number of conflicts reach
		MAX_CONFLICTS(10) then the host should not send any ARP request within
		RATE_LIMIT_INTERVAL seconds after the 10th conflict)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>208</ID>
		<API>208</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_15</Name>
		<Protocol>IPv4</Protocol>
		<Description>If the number of conflicts exceeds MAX_CONFLICTS then the host MUST limit the rate at
		which it probes for new addresses to no more than one new address per
		RATE_LIMIT_INTERVAL. (Note : Here TESTER checks that if number of conflicts reach
		MAX_CONFLICTS(10) then the host should send only 1 ARP request after the
		RATE_LIMIT_INTERVAL seconds get over, within the next RATE_LIMIT_INTERVAL seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>209</ID>
		<API>209</API>
		<Name>IPv4_AUTOCONF_ADDRESS_SELECTION_16</Name>
		<Protocol>IPv4</Protocol>
		<Description>If, by ANNOUNCE_WAIT seconds after the transmission of the last ARP Probe no
		conflicting ARP Reply or ARP Probe has been received, then the host has successfully
		claimed the desired IPv4 Link-Local address.</Description>
		<Subprotocol>IPv4_AUTOCONF_ADDRESS_SELECTION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>210</ID>
		<API>210</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>An ARP announcement is identical to the ARP Probe described above, except that now the
		sender and target IP addresses are both set to the host's newly selected IPv4 address. In
		this document, the term 'ARP Announcement' is used to refer to an ARP Request packet,
		broadcast on the local link, identical to the ARP Probe described above, except that both
		the sender and target IP address fields contain the IP address being announced. (Note: Here
		TESTER checks that after receiving 3 ARP Probes from DUT interface, TESTER receives an
		ARP Announcement(Request) packet with Destination MAC address set to Ethernet
		Broadcast Address.A tolerance time of -0.05 seconds is used at the step where TESTER is
		waiting up to ANNOUNCE_WAIT seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>211</ID>
		<API>211</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_02</Name>
		<Protocol>IPv4</Protocol>
		<Description>An ARP announcement is identical to the ARP Probe described above, except that now the
		sender and target IP addresses are both set to the host's newly selected IPv4 address. In
		this document, the term 'ARP Announcement' is used to refer to an ARP Request packet,
		broadcast on the local link, identical to the ARP Probe described above, except that both
		the sender and target IP address fields contain the IP address being announced. (Note: Here
		TESTER checks that after receiving 3 ARP Probes from DUT interface, TESTER receives an
		ARP Announcement(Request) packet with Source IP address = Target IP address =
		Announced IP address. A tolerance time of -0.05 seconds is used at the step where TESTER
		is waiting up to ANNOUNCE_WAIT seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>212</ID>
		<API>212</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_03</Name>
		<Protocol>IPv4</Protocol>
		<Description>An ARP announcement is identical to the ARP Probe described above, except that now the
		sender and target IP addresses are both set to the host's newly selected IPv4 address. In
		this document, the term 'ARP Announcement' is used to refer to an ARP Request packet,
		broadcast on the local link, identical to the ARP Probe described above, except that both
		the sender and target IP address fields contain the IP address being announced. (Note: Here
		TESTER checks that after receiving 3 ARP Probes from DUT interface, TESTER receives an
		ARP Announcement(Request) packet with Sender Hardware address set to DUT interface
		MAC Address. A tolerance time of -0.05 seconds is used at the step where TESTER is waiting
		up to ANNOUNCE_WAIT seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>213</ID>
		<API>213</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>An ARP announcement is identical to the ARP Probe described above, except that now the
		sender and target IP addresses are both set to the host's newly selected IPv4 address. In
		this document, the term 'ARP Announcement' is used to refer to an ARP Request packet,
		broadcast on the local link, identical to the ARP Probe described above, except that both
		the sender and target IP address fields contain the IP address being announced. (Note: Here
		TESTER checks that after receiving 3 ARP Probes from DUT interface, TESTER receives an
		ARP Announcement(Request) packet with Target Hardware address set to all zeroes. A
		tolerance time of -0.05 seconds is used at the step where TESTER is waiting up to
		ANNOUNCE_WAIT seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>214</ID>
		<API>214</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_05</Name>
		<Protocol>IPv4</Protocol>
		<Description>Having probed to determine a unique address to use, the host MUST then announce its 
		claimed address by broadcasting ANNOUNCE_NUM ARP announcements, spaced
		ANNOUNCE_INTERVAL seconds apart. (Note : A tolerance time of -0.05 seconds is used at
		the step where TESTER is waiting up to ANNOUNCE_WAIT seconds)</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>215</ID>
		<API>215</API>
		<Name>IPv4_AUTOCONF_ANNOUNCING_06</Name>
		<Protocol>IPv4</Protocol>
		<Description>Having probed to determine a unique address to use, the host MUST then announce its 
		claimed address by broadcasting ANNOUNCE_NUM ARP announcements, spaced
		ANNOUNCE_INTERVAL seconds apart. (Note : Here TESTER is verifying that the time gap
		between the two announce messages is. Tolerance is 50 milliseconds. A tolerance time of -0.05 seconds is used at the step where TESTER is
		waiting up to ANNOUNCE_WAIT seconds).</Description>
		<Subprotocol>IPv4_AUTOCONF_ANNOUNCING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>216</ID>
		<API>216</API>
		<Name>IPv4_AUTOCONF_CONFLICT_06</Name>
		<Protocol>IPv4</Protocol>
		<Description>If this is not the first conflicting ARP packet the host has seen, and the time recorded for the
		previous conflicting ARP packet is recent, within DEFEND_INTERVAL seconds, then the host
		MUST immediately cease using this address and configure a new IPv4 Link-Local address.
		(Note:In this test case, TESTER sends 2 conflicting ARP Request mesages with both sourceand target IP address set to the advertised link local address, within DEFEND_INTERVAL
		seconds, and check if DUT probes with a new advertised link local address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>217</ID>
		<API>217</API>
		<Name>IPv4_AUTOCONF_CONFLICT_07</Name>
		<Protocol>IPv4</Protocol>
		<Description>If this is not the first conflicting ARP packet the host has seen, and the time recorded for the
		previous conflicting ARP packet is recent, within DEFEND_INTERVAL seconds, then the host
		MUST immediately cease using this address and configure a new IPv4 Link-Local address.
		(Note:In this test case, TESTER sends 2 conflicting ARP Response messages with both source
		and target IP address set to the advertised link local address, within DEFEND_INTERVAL
		seconds and check if DUT probes with a new advertised link local address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>218</ID>
		<API>218</API>
		<Name>IPv4_AUTOCONF_CONFLICT_08</Name>
		<Protocol>IPv4</Protocol>
		<Description>If this is not the first conflicting ARP packet the host has seen, and the time recorded for the
		previous conflicting ARP packet is recent, within DEFEND_INTERVAL seconds, then the host
		MUST immediately cease using this address and configure a new IPv4 Link-Local address.
		(Note:In this test case, TESTER first sends 1 conflicting ARP Request mesages and then sends
		1 conflicting ARP Response message, within DEFEND_INTERVAL seconds, and check if DUT
		probes with a new advertised link local address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>219</ID>
		<API>219</API>
		<Name>IPv4_AUTOCONF_CONFLICT_09</Name>
		<Protocol>IPv4</Protocol>
		<Description>If this is not the first conflicting ARP packet the host has seen, and the time recorded for the
		previous conflicting ARP packet is recent, within DEFEND_INTERVAL seconds, then the host
		MUST immediately cease using this address and configure a new IPv4 Link-Local address.
		(Note:In this test case, TESTER first sends 1 conflicting ARP Response message and then
		sends 1 conflicting ARP request message, within DEFEND_INTERVAL seconds and check if
		DUT probes with a new advertised link local address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>220</ID>
		<API>220</API>
		<Name>IPv4_AUTOCONF_CONFLICT_10</Name>
		<Protocol>IPv4</Protocol>
		<Description>Upon receiving a conflicting ARP packet, a host MAY elect to immediately configure a new
		IPv4 Link-Local address. (Note: In this test case, TESTER is sending a conflicting ARP
		Response message with source IP Address and target IP Address both set to probed linklocal
		address sent by the DUT and checks whether DUT sends a probe with a different link local address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>221</ID>
		<API>221</API>
		<Name>IPv4_AUTOCONF_CONFLICT_11</Name>
		<Protocol>IPv4</Protocol>
		<Description>All ARP packets (*replies* as well as requests ) that contain a Link- Local 'sender IP address' 
		MUST be sent using link-layer broadcast instead of link-layer unicast. (Note:Here TESTER
		checks that DUT sends ARP Probe Response with Ethernet destination address set to
		broadcast address)</Description>
		<Subprotocol>IPv4_AUTOCONF_CONFLICT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>222</ID>
		<API>222</API>
		<Name>IPv4_AUTOCONF_LINKLOCAL_PACKETS_04</Name>
		<Protocol>IPv4</Protocol>
		<Description>A router or other host MUST NOT indiscriminately answer all ARP Requests for addresses in
		the 169.254/16 prefix. A router may of course answer ARP Requests for one or more IPv4
		Link-Local address(es) that it has legitimately claimed for its own use according to the claimand-defend protocol described in this document.
		(Note: Here TESTER checks that the router/host will not answer to the ARP request for an arbitrary link-local address which it is not using)</Description>
		<Subprotocol>IPv4_AUTOCONF_LINKLOCAL_PACKETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>223</ID>
		<API>223</API>
		<Name>IPv4_AUTOCONF_NETWORK_PARTITIONS_01</Name>
		<Protocol>IPv4</Protocol>
		<Description>Hosts SHOULD NOT send periodic gratuitous ARPs (Note: for Link-Local Addresses).</Description>
		<Subprotocol>IPv4_AUTOCONF_NETWORK_PARTITIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>224</ID>
		<API>224</API>
		<Name>DHCPv4_CLIENT_SUMMARY_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>A DHCP Client Listens on UDP port 68</Description>
		<Subprotocol>DHCPv4_CLIENT_SUMMARY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>225</ID>
		<API>225</API>
		<Name>DHCPv4_CLIENT_SUMMARY_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>A DHCP client must be prepared to receive multiple responses to a request for 
		configuration parameters (Note: If the 'xid' of an arriving DHCPOFFER message does not
		match the 'xid' of the most recent DHCPDISCOVER message, the DHCPOFFER message must
		be silently discarded.) </Description>
		<Subprotocol>DHCPv4_CLIENT_SUMMARY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>226</ID>
		<API>226</API>
		<Name>DHCPv4_CLIENT_SUMMARY_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>A DHCP client must be prepared to receive DHCP messages with an 'options' field of at
		least length 312 octets. This requirement implies that a DHCP client must be prepared to
		receive a message of up to 576 octets</Description>
		<Subprotocol>DHCPv4_CLIENT_SUMMARY</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>227</ID>
		<API>227</API>
		<Name>DHCPv4_CLIENT_PROTOCOL_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>The first four octets of the 'options' field of the DHCP message contain the (decimal)
		values 99, 130, 83 and 99, respectively (this is the same magic cookie as is defined in RFC 1497)</Description>
		<Subprotocol>DHCPv4_CLIENT_PROTOCOL</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>228</ID>
		<API>228</API>
		<Name>DHCPv4_CLIENT_PROTOCOL_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>One particular option - the \"DHCP message type\" option - must be included in every
		DHCP message (Note: This test verifies the above statement for DHCP DISCOVE Message)</Description>
		<Subprotocol>DHCPv4_CLIENT_PROTOCOL</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>229</ID>
		<API>229</API>
		<Name>DHCPv4_CLIENT_PROTOCOL_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>One particular option - the \"DHCP message type\" option - must be included in every 
		DHCP message (Note: This test verifies the above statement for DHCPREQUEST Message)</Description>
		<Subprotocol>DHCPv4_CLIENT_PROTOCOL</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>230</ID>
		<API>230</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client broadcasts a DHCPDISCOVER message on its local physical subnet</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>231</ID>
		<API>231</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client broadcasts a DHCPREQUEST message that MUST include the 'server identifier' option to indicate which server it has selected </Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>232</ID>
		<API>232</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_04</Name>
		<Protocol>DHCP</Protocol>
		<Description>the DHCPREQUEST message MUST use the same value in the DHCP message header's 'secs' field ... as the original DHCPDISCOVER message</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>233</ID>
		<API>233</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_05</Name>
		<Protocol>DHCP</Protocol>
		<Description>the DHCPREQUEST message MUST ... be sent to the same IP broadcast address as the original DHCPDISCOVER message</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>234</ID>
		<API>234</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_06</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client times out and retransmits the DHCPDISCOVER message if the client receives no DHCPOFFER messages</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>235</ID>
		<API>235</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_07</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the client detects that the address is already in use (e.g., through the use of ARP), the 
		client MUST send a DHCPDECLINE message to the server and restarts the configuration
		process (Note: In this test we check that the DUT does restart the configuration process
		after sending the DHCPDECLINE Message)</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>236</ID>
		<API>236</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_08</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client SHOULD wait a minimum of ten seconds before restarting the configuration process to avoid excessive network traffic in case of looping</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>237</ID>
		<API>237</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_09</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the client receives a DHCPNAK message, the client restarts the configuration process</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>238</ID>
		<API>238</API>
		<Name>DHCPv4_CLIENT_ALLOCATING_10</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client times out and retransmits the DHCPREQUEST message if the client receives neither a DHCPACK or a DHCPNAK message</Description>
		<Subprotocol>DHCPv4_CLIENT_ALLOCATING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>239</ID>
		<API>239</API>
		<Name>DHCPv4_CLIENT_PARAMETERS_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>First, most of the parameters have defaults defined in the Host Requirements RFCs; if the 
		client receives no parameters from the server that override the defaults, a client uses those
		default values (Note: This test checks that if default value is overridden, DUT uses the
		overridden value for Time To Live)</Description>
		<Subprotocol>DHCPv4_CLIENT_PARAMETERS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>240</ID>
		<API>240</API>
		<Name>DHCPv4_CLIENT_PARAMETERS_04</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the client includes a list of parameters in a DHCPDISCOVER message, it MUST include 
		that list in any subsequent DHCPREQUEST messages.</Description>
		<Subprotocol>DHCPv4_CLIENT_PARAMETERS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>241</ID>
		<API>241</API>
		<Name>DHCPv4_CLIENT_USAGE_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>A client with multiple network interfaces must use DHCP through each interface
		independently to obtain configuration information parameters for those separateinterfaces</Description>
		<Subprotocol>DHCPv4_CLIENT_USAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>242</ID>
		<API>242</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>The last option must always be the 'end' option</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>243</ID>
		<API>243</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCP clients MUST use the IP address provided in the 'server identifier' option for any unicast requests to the DHCP server</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>244</ID>
		<API>244</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCP messages broadcast by a client prior to that client obtaining its IP address must have
		the source address field in the IP header set to 0 (Note: This test verifies source IP address
		field of DHCPDISCOVER Message)</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>245</ID>
		<API>245</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_04</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCP messages broadcast by a client prior to that client obtaining its IP address must have
		the source address field in the IP header set to 0 (Note: This test verifies source IP address
		field of DHCPREQUEST Message)</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>246</ID>
		<API>246</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_05</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the options in a DHCP message extend into the 'sname' and 'file' fields, the 'option 
		overload' option MUST appear in the 'options' field, with value 1, 2 or 3 (Note: Here we
		verify that DUT correctly parses 'sname' field when Option Overload is present and set to
		'sname contains options')</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>247</ID>
		<API>247</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_06</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the options in a DHCP message extend into the 'sname' and 'file' fields, the 'option 
		overload' option MUST appear in the 'options' field, with value 1, 2 or 3 (Note: Here we
		verify that DUT correctly parses 'file' field when Option Overload is present and set to 'file
		contains options')</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>248</ID>
		<API>248</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_12</Name>
		<Protocol>DHCP</Protocol>
		<Description>The retransmission delay SHOULD be doubled with subsequent retransmissions up to a maximum of 64 seconds</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>249</ID>
		<API>249</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_13</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client MUST adopt a retransmission strategy that incorporates a randomized 
		exponential backoff algorithm to determine the delay between retransmissions</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>250</ID>
		<API>250</API>
		<Name>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES_14</Name>
		<Protocol>DHCP</Protocol>
		<Description>For example, a client may choose a different, random initial 'xid' each time the client is rebooted</Description>
		<Subprotocol>DHCPv4_CLIENT_CONSTRUCTING_MESSAGES</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>251</ID>
		<API>251</API>
		<Name>DHCPv4_CLIENT_REQUEST_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>Client inserts ... , 'ciaddr' MUST be zero</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>252</ID>
		<API>252</API>
		<Name>DHCPv4_CLIENT_REQUEST_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>requested IP address' MUST be filled in with the yiaddr value from the chosen DHCPOFFER.</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>253</ID>
		<API>253</API>
		<Name>DHCPv4_CLIENT_REQUEST_06</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during RENEWING state: 'server identifier' MUST NOT be filled in</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>254</ID>
		<API>254</API>
		<Name>DHCPv4_CLIENT_REQUEST_07</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during RENEWING state: 'requested IP address' option MUST NOT be filled in</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>255</ID>
		<API>255</API>
		<Name>DHCPv4_CLIENT_REQUEST_08</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during RENEWING state: ciaddr' MUST be filled in with client's IP address</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>256</ID>
		<API>256</API>
		<Name>DHCPv4_CLIENT_REQUEST_09</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during REBINDING state: 'server identifier' MUST NOT be filled in</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>257</ID>
		<API>257</API>
		<Name>DHCPv4_CLIENT_REQUEST_10</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during REBINDING state: 'requested IP address' option MUST NOT be filled in</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>258</ID>
		<API>258</API>
		<Name>DHCPv4_CLIENT_REQUEST_11</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during REBINDING state: 'ciaddr' MUST be filled in with client's IP address</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>259</ID>
		<API>259</API>
		<Name>DHCPv4_CLIENT_REQUEST_12</Name>
		<Protocol>DHCP</Protocol>
		<Description>DHCPREQUEST generated during REBINDING state: This message MUST be broadcast to the 0xffffffff IP broadcast address</Description>
		<Subprotocol>DHCPv4_CLIENT_REQUEST</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>260</ID>
		<API>260</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client SHOULD wait a random time between one and ten seconds to desynchronize the use of DHCP at startup</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>261</ID>
		<API>261</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client begins in INIT state and forms a DHCPDISCOVER message ... The client sets 'ciaddr' to 0x00000000</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>262</ID>
		<API>262</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client begins in INIT state and forms a DHCPDISCOVER message ... The client MUST 
		include its hardware address in the 'chaddr' field</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>263</ID>
		<API>263</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_04</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the 'xid' of an arriving DHCPOFFER message does not match the 'xid' of the most recent 
		DHCPDISCOVER message, the DHCPOFFER message must be silently discarded</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>264</ID>
		<API>264</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_05</Name>
		<Protocol>DHCP</Protocol>
		<Description>Any arriving DHCPACK messages must be silently discarded</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>265</ID>
		<API>265</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_06</Name>
		<Protocol>DHCP</Protocol>
		<Description>The DHCPREQUEST message contains the same 'xid' as the DHCPOFFER message</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>266</ID>
		<API>266</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_08</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client SHOULD perform a check on the suggested address to ensure that the address is
		not already in use... the client must fill in its own hardware address as the sender's
		hardware address, and 0 as the sender's IP address</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>267</ID>
		<API>267</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_09</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the network address appears to be in use, the client MUST send a DHCPDECLINE 
		message to the server</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>268</ID>
		<API>268</API>
		<Name>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION_10</Name>
		<Protocol>DHCP</Protocol>
		<Description>The client SHOULD broadcast an ARP reply to announce the client's new IP address and
		clear any outdated ARP cache entries in hosts on the client's subnet</Description>
		<Subprotocol>DHCPv4_CLIENT_INITIALIZATION_ALLOCATION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>269</ID>
		<API>269</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_01</Name>
		<Protocol>DHCP</Protocol>
		<Description>At time T1 the client moves to RENEWING state and sends (via unicast) a DHCPREQUEST 
		message to the server to extend its lease</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>270</ID>
		<API>270</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_02</Name>
		<Protocol>DHCP</Protocol>
		<Description>If no DHCPACK arrives before time T2, the client moves to REBINDING state and sends 
		(via broadcast) a DHCPREQUEST message to extend its lease</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>271</ID>
		<API>271</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_03</Name>
		<Protocol>DHCP</Protocol>
		<Description>T1 defaults to (0.5 * duration_of_lease). T2 defaults to (0.875 * duration_of_lease). TimesT1 and T2 SHOULD be chosen with some random \"fuzz\" around a fixed value, to avoid
		synchronization of client reacquisition (Note: This test verifies the value of T1)</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>272</ID>
		<API>272</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_04</Name>
		<Protocol>DHCP</Protocol>
		<Description>T1 defaults to (0.5 * duration_of_lease). T2 defaults to (0.875 * duration_of_lease). Times
		T1 and T2 SHOULD be chosen with some random \"fuzz\" around a fixed value, to avoid
		synchronization of client reacquisition (Note: This test verifies the value of T2)</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>273</ID>
		<API>273</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_05</Name>
		<Protocol>DHCP</Protocol>
		<Description>In both RENEWING and REBINDING states, if the client receives no response to its 
		DHCPREQUEST message, the client SHOULD wait one-half of the remaining time until T2 (in
		RENEWING state) and one-half of the remaining lease time (in REBINDING state), down to a
		minimum of 60 seconds, before retransmitting the DHCPREQUEST message.</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>274</ID>
		<API>274</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_06</Name>
		<Protocol>DHCP</Protocol>
		<Description>In both RENEWING and REBINDING states, if the client receives no response to its 
		DHCPREQUEST message, the client SHOULD wait one-half of the remaining time until T2 (in
		RENEWING state) and one-half of the remaining lease time (in REBINDING state), down to a
		minimum of 60 seconds, before retransmitting the DHCPREQUEST message.</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>275</ID>
		<API>275</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_07</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the lease expires before the client receives a DHCPACK, the client moves to INIT state, 
		MUST immediately stop any other network processing and requests network initialization
		parameters as if the client were uninitialized (Note: In this test we verify that the DUT stops
		network processing after lease time expires)</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>276</ID>
		<API>276</API>
		<Name>DHCPv4_CLIENT_REACQUISITION_08</Name>
		<Protocol>DHCP</Protocol>
		<Description>If the lease expires before the client receives a DHCPACK, the client moves to INIT state, 
		MUST immediately stop any other network processing and requests network initialization
		parameters as if the client were uninitialized (Note: In this test we verify that the DUT
		requests network initialization parameters after lease time expires)</Description>
		<Subprotocol>DHCPv4_CLIENT_REACQUISITION</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>277</ID>
		<API>277</API>
		<Name>SOMEIPSRV_FORMAT_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Client ID shall be set statically to 0x0000</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>278</ID>
		<API>278</API>
		<Name>SOMEIPSRV_FORMAT_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>After initialization of the Service Discovery Module, the Session ID for messages sent by the local ECU shall be 0x0001.</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>279</ID>
		<API>279</API>
		<Name>SOMEIPSRV_FORMAT_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The value for the Protocol Version field shall be statically set to 0x01</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>280</ID>
		<API>280</API>
		<Name>SOMEIPSRV_FORMAT_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The value for the Interface Version field shall be statically set to 0x01</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>281</ID>
		<API>281</API>
		<Name>SOMEIPSRV_FORMAT_05</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The value for the Message Type field shall be statically set to 0x02</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>282</ID>
		<API>282</API>
		<Name>SOMEIPSRV_FORMAT_06</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Return Code field shall be statically set to 0x00 Note: This test case is for SD message</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>283</ID>
		<API>283</API>
		<Name>SOMEIPSRV_FORMAT_07</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reboot Flag shall be set to '1' for all messages after reboot until the Session ID of the Request ID field wraps and thus starts with 0x0001 again. After that the Reboot Flag shall be set to '0'.</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>284</ID>
		<API>284</API>
		<Name>SOMEIPSRV_FORMAT_08</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Unicast Flag of the Flag field shall be set to Unicast Flag and shall be set to  '1', meaning: This ECU supports receiving Unicast messages.</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>285</ID>
		<API>285</API>
		<Name>SOMEIPSRV_FORMAT_09</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Undefined bits within the Flag field shall be statically set to '0'</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>286</ID>
		<API>286</API>
		<Name>SOMEIPSRV_FORMAT_10</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>All bits of the Reserved field shall be statically set to 0 binary.</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>287</ID>
		<API>287</API>
		<Name>SOMEIPSRV_FORMAT_11</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The length of the Type 1 Entry shall be 16 bytes Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>288</ID>
		<API>288</API>
		<Name>SOMEIPSRV_FORMAT_12</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The "Index First Option Run" field of the Type 1 Entry format layout shall carry the index of the first option of the first option run of this entry in the option array.
		Note : Offer Service is under Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>289</ID>
		<API>289</API>
		<Name>SOMEIPSRV_FORMAT_13</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>[SWS_SD_00168] The "Number of Option 1" of the Type 1 Entry format layout shall carry the number of options the first option run uses. Note : Offer Service is under Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>290</ID>
		<API>290</API>
		<Name>SOMEIPSRV_FORMAT_14</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Service ID field of the Type 1 Entry format layout shall carry the Service ID of  the service, statically configured using the parameter SdServerServiceID and SdClientServiceID, depending on being a server or client entry. Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>291</ID>
		<API>291</API>
		<Name>SOMEIPSRV_FORMAT_15</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Instance ID field of the Type 1 Entry format layout shall carry the Instance ID  of the service, statically configured using the parameter SdServerServiceInstanceID and SdClientServiceInstanceID, depending on being a server or client entry. Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>292</ID>
		<API>292</API>
		<Name>SOMEIPSRV_FORMAT_16</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Major Version field of the Type 1 Entry format layout shall carry the SdServerServiceMajorVersion and SdClientServiceMajorVersion, depending on
		being a server or client entry. Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>293</ID>
		<API>293</API>
		<Name>SOMEIPSRV_FORMAT_17</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The TTL field of the Type 1 Entry format layout defines the lifetime of the entry in  seconds configured using the parameter SdServerTimerTTL and SdClientTimerTTL, except for Stop-Entries, which have a TTL of 0 Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>294</ID>
		<API>294</API>
		<Name>SOMEIPSRV_FORMAT_18</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Minor Version field of the Type 1 Entry format layout shall carry the SdServerServiceMinorVersion and SdClientServiceMinorVersion. Note : Offer Service is unnder Entry Type 1</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>295</ID>
		<API>295</API>
		<Name>SOMEIPSRV_FORMAT_19</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Type field of the Type 2 Entry format layout shall carry one of the following values, depending of the purpose of the sent message: 0x06 to encode
		SubscribeEventgroup and StopSubscribeEventgroup 0x07 to encode SubscribeEventgroupAck and SubscribeEventgroupNack Note :
		SubscribeEventgroupAck is unnder Entry Type 2 Test case is to verify SubscribeEventgroupAck</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>296</ID>
		<API>296</API>
		<Name>SOMEIPSRV_FORMAT_20</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The length of Type 2 Entries shall be 16 bytes. Note : SubscribeEventgroupAck is unnder Entry Type 2 </Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>297</ID>
		<API>297</API>
		<Name>SOMEIPSRV_FORMAT_21</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The "Index First Option Run" field of the Type 2 Entry format layout shall carry the index of the first option of the first option run of this entry in the option array. Note: SubscribeEventgroupAck is under Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>298</ID>
		<API>298</API>
		<Name>SOMEIPSRV_FORMAT_23</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Service ID field of the Type 2 Entry format layout shall carry the Service ID of  the eventgroups service, statically configured using the parameter
		SdServerServiceID and SdClientServiceID, depending on being a server or client entry. Note : SubscribeEventgroupAck is under Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>299</ID>
		<API>299</API>
		<Name>SOMEIPSRV_FORMAT_24</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Instance ID field of the Type 2 Entry format layout shall carry the Instance ID  of the eventgroups service statically configured using the parameter SdServerServiceInstanceID and SdClientServiceInstanceID, depending on being a
		server or client entry. Note : SubscribeEventgroupAck is unnder Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>300</ID>
		<API>300</API>
		<Name>SOMEIPSRV_FORMAT_25</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Major Version field of the Type 2 Entry format layout shall carry the  SdServerServiceMajorVersion and SdClientServiceMajorVersion, depending on being a server or client entry. Note : SubscribeEventgroupAck is under Entry Type2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>301</ID>
		<API>301</API>
		<Name>SOMEIPSRV_FORMAT_26</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The TTL field of the Type 2 Entry Entry format layout defines the lifetime of the entry in seconds configured using the parameter SdServerTimerTTL and SdClientTimerTTL, except for Stop- or Nack-Entries, which use a TTL of 0. Note : SubscribeEventgroupAck is under Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>302</ID>
		<API>302</API>
		<Name>SOMEIPSRV_FORMAT_27</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reserved field, which follows the TTL field of the Type 2 Entry format layout, shall be statically set to 0x0000. Note : SubscribeEventgroupAck is under
		Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>303</ID>
		<API>303</API>
		<Name>SOMEIPSRV_FORMAT_28</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Eventgroup ID field of the Type 2 Entry format layout shall carry the ID of an Eventgroup, configured using the parameter SdConsumedEventGroupID. Note : SubscribeEventgroupAck is under Entry Type 2</Description>
		<Subprotocol>SOMEIPSRV_FORMAT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>304</ID>
		<API>304</API>
		<Name>SOMEIPSRV_OPTIONS_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Length field of the IPv4 Endpoint Option shall be set to 0x0009</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>305</ID>
		<API>305</API>
		<Name>SOMEIPSRV_OPTIONS_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Type field of the IPv4 Endpoint Option shall be statically set to 0x04.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>306</ID>
		<API>306</API>
		<Name>SOMEIPSRV_OPTIONS_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reserved field of the IPv4 Endpoint Option (followed by the IPv4-Address  field) of the Configuration Option segment shall be statically set to 0x00.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>307</ID>
		<API>307</API>
		<Name>SOMEIPSRV_OPTIONS_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The IPv4-Address field [32 bits] of the IPv4 Endpoint Option shall be set to the  local IP address of the relevant Service or Eventgroup.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>308</ID>
		<API>308</API>
		<Name>SOMEIPSRV_OPTIONS_05</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reserved field of the IPv4 Endpoint Option shall statically be set to 0x00.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>309</ID>
		<API>309</API>
		<Name>SOMEIPSRV_OPTIONS_06</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Layer 4 Protocol field [8 bits] (L4-Proto) of the IPv4 Endpoint Option shall be set to one of the following values, depending on the port specified: 0x06: TCP 0x11: UDP NOTE: Checking For UDP.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>310</ID>
		<API>310</API>
		<Name>SOMEIPSRV_OPTIONS_07</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Port Number field [16 bits] of the IPv4 Endpoint Option shall carry the UDP  or TCP port number for the service instance or Eventgroup.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>311</ID>
		<API>311</API>
		<Name>SOMEIPSRV_OPTIONS_08</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Length field [16 bits] of the IPv4 Multicast Option shall be set to 0x0009.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>312</ID>
		<API>312</API>
		<Name>SOMEIPSRV_OPTIONS_09</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Type field [8 bits] of the IPv4 Multicast Option shall be statically set to  0x14.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>313</ID>
		<API>313</API>
		<Name>SOMEIPSRV_OPTIONS_10</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reserved field [8 bits] of the IPv4 Multicast Option (followed by the IPv4- Address field) of the Configuration Option segment shall be statically set to 0x00.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>314</ID>
		<API>314</API>
		<Name>SOMEIPSRV_OPTIONS_11</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The IPv4-Address field [32 bits] of the IPv4 Multicast Option shall be set to the Multicast IP address of the Eventgroup.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>315</ID>
		<API>315</API>
		<Name>SOMEIPSRV_OPTIONS_12</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Reserved field [8 bits] of the IPv4 Multicast Option shall statically be set to 0x00.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>316</ID>
		<API>316</API>
		<Name>SOMEIPSRV_OPTIONS_13</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Layer 4 Protocol field [8 bits] (L4-Proto) of the IPv4 Multicast Option shall be set to 0x11 (UDP).</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>317</ID>
		<API>317</API>
		<Name>SOMEIPSRV_OPTIONS_14</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Port Number field [16 bits] of the IPv4 Multicast Option shall carry the port number for transporting Multicast Events of the Eventgroup.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>318</ID>
		<API>318</API>
		<Name>SOMEIPSRV_OPTIONS_15</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Layer 4 Protocol field [8 bits] (L4-Proto) of the IPv4 Endpoint Option shall be set to one of the following values, depending on the port specified: 0x06: TCP 0x11: UDP NOTE: Checking For TCP.</Description>
		<Subprotocol>SOMEIPSRV_OPTIONS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>319</ID>
		<API>319</API>
		<Name>SOMEIPSRV_SD_MESSAGE_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Instance ID shall be set to 0xFFFF, if all service instances shall be returned. It shall be set to the Instance ID of a specific service instance, if just a single service instance shall be returned. NOTE: Checking For Instance ID 0xFFFF.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>320</ID>
		<API>320</API>
		<Name>SOMEIPSRV_SD_MESSAGE_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Instance ID shall be set to 0xFFFF, if all service instances shall be returned. It shall be set to the Instance ID of a specific service instance, if just a single service instance shall be returned. NOTE: Checking For Specific Instance ID.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>321</ID>
		<API>321</API>
		<Name>SOMEIPSRV_SD_MESSAGE_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Major Version shall be set to 0xFF, that means that services with any version shall be returned. If set to value different than 0xFF, services with this specific major version shall be returned only. NOTE: Checking For Major Version 0xFF.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>322</ID>
		<API>322</API>
		<Name>SOMEIPSRV_SD_MESSAGE_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Major Version shall be set to 0xFF, that means that services with any version shall be returned. If set to value different than 0xFF, services with this specific major version shall be returned only. NOTE: Checking For Specific Major Version.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>323</ID>
		<API>323</API>
		<Name>SOMEIPSRV_SD_MESSAGE_05</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Minor Version shall be set to 0xFFFF FFFF, that means that services with any  version shall be returned. If set to a value different to 0xFFFF FFFF, services with this specific minor version shall be returned only. NOTE: Checking For Minor
	Version 0xFFFFFFFF.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>324</ID>
		<API>324</API>
		<Name>SOMEIPSRV_SD_MESSAGE_06</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Minor Version shall be set to 0xFFFF FFFF, that means that services with any  version shall be returned. If set to a value different to 0xFFFF FFFF, services with this specific minor version shall be returned only. NOTE: Checking For Specific Minor Version.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>325</ID>
		<API>325</API>
		<Name>SOMEIPSRV_SD_MESSAGE_07</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>TTL shall be set to the lifetime of the service instance. After this lifetime the service instance shall considered not been offered.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>326</ID>
		<API>326</API>
		<Name>SOMEIPSRV_SD_MESSAGE_08</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Offer Service entries shall always reference at least an IPv4 or IPv6 Endpoint  Option to signal how the service is reachable. NOTE: Test is for IPv4.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>327</ID>
		<API>327</API>
		<Name>SOMEIPSRV_SD_MESSAGE_09</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The IP addresses and port numbers of the Endpoint Options shall also be used for transporting events and notification events, In the case of UDP this information is used for the source address and the source port of the events and notification events.
		NOTE: This test is for UDP port.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>328</ID>
		<API>328</API>
		<Name>SOMEIPSRV_SD_MESSAGE_11</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup entry type shall be used to subscribe to an eventgroup.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>329</ID>
		<API>329</API>
		<Name>SOMEIPSRV_SD_MESSAGE_13</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was accepted. Subscribe Eventgroup Acknowledgment
		entries shall set the entry fields in the following way: Type shall be set to 0x07(SubscribeEventgroupAck). Service ID, Instance ID, Major Version, Eventgroup ID,
		TTL, and Reserved shall be the same value as in the Subcribe that is beinganswered.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>330</ID>
		<API>330</API>
		<Name>SOMEIPSRV_SD_MESSAGE_14</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup Negative Acknowledgment entries shall set the entry fields in the following way:
		Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID, Major Version, Eventgroup ID and Reserved shall be the same value as in the subscribe that is being answered. The TTL shall be set to 0x000000. NOTE: Check For TTL Field and Type.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>331</ID>
		<API>331</API>
		<Name>SOMEIPSRV_SD_MESSAGE_15</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup
		Negative Acknowledgment entries shall set the entry fields in the following way: Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID,
		Major Version, Eventgroup ID and Reserved shall be the same value as in the subscribe that is being answered. The TTL shall be set to 0x000000. NOTE:
		Checking for later Condition that Service ID, Instance ID, Major Version, Eventgroup ID and Reserved shall be the same value as in the subscribe .</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>332</ID>
		<API>332</API>
		<Name>SOMEIPSRV_SD_MESSAGE_16</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup Negative Acknowledgment entries shall set the entry fields in the following way:
		Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID, Major Version, Eventgroup ID and Reserved shall be the same value as in the subscribe that is being answered. The TTL shall be set to 0x000000. Reasons for sending a Subscribe Eventgroup Negative Acknowledgment include: Combination of Service ID, Instance ID, Eventgroup ID, and Major Version is unknown. NOTE:
		Test For Unknown Service ID.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>333</ID>
		<API>333</API>
		<Name>SOMEIPSRV_SD_MESSAGE_17</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup Negative Acknowledgment entries shall set the entry fields in the following way:
		Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID,Major Version, Eventgroup ID and Reserved shall be the same value as in the
		subscribe that is being answered. The TTL shall be set to 0x000000. Reasons for sending a Subscribe Eventgroup Negative Acknowledgment include: Combination of Service ID, Instance ID, Eventgroup ID, and Major Version is unknown. NOTE:
		Test For Unknown Instance ID.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>334</ID>
		<API>334</API>
		<Name>SOMEIPSRV_SD_MESSAGE_18</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup
		Negative Acknowledgment entries shall set the entry fields in the following way: Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID, Major Version, Eventgroup ID and Reserved shall be the same value as in the
		subscribe that is being answered. The TTL shall be set to 0x000000. Reasons for sending a Subscribe Eventgroup Negative Acknowledgment include: Combination of Service ID, Instance ID, Eventgroup ID, and Major Version is unknown. NOTE:
		Test For Unknown Major Version.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>335</ID>
		<API>335</API>
		<Name>SOMEIPSRV_SD_MESSAGE_19</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Subscribe Eventgroup Negative Acknowledgment entry type shall be used to indicate that Subscribe Eventgroup entry was NOT accepted. Subscribe Eventgroup Negative Acknowledgment entries shall set the entry fields in the following way:
		Type shall be set to 0x07 (SubscribeEventgroupAck). Service ID, Instance ID, Major Version, Eventgroup ID and Reserved shall be the same value as in the
		subscribe that is being answered. The TTL shall be set to 0x000000. Reasons for sending a Subscribe Eventgroup Negative Acknowledgment include: Combination of Service ID, Instance ID, Eventgroup ID, and Major Version is unknown. NOTE: Test For Unknown Event Group ID.</Description>
		<Subprotocol>SOMEIPSRV_SD_MESSAGE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>336</ID>
		<API>336</API>
		<Name>SOMEIPSRV_SD_BEHAVIOR_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>After sending the first message the Repetition Phase of this Service Instance/these Service Instances is entered. After each message sent in the Repetition Phase the delay is doubled.</Description>
		<Subprotocol>SOMEIPSRV_SD_BEHAVIOR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>337</ID>
		<API>337</API>
		<Name>SOMEIPSRV_SD_BEHAVIOR_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>In the Main Phase Offer Messages and Publish Messages shall be sent cyclically 
		if a CYCLIC_OFFER_DELAY is configured.</Description>
		<Subprotocol>SOMEIPSRV_SD_BEHAVIOR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>338</ID>
		<API>338</API>
		<Name>SOMEIPSRV_SD_BEHAVIOR_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIPSRV_SD_BEHAVIOR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>339</ID>
		<API>339</API>
		<Name>SOMEIPSRV_SD_BEHAVIOR_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Find messages received with Unicast Flag set to 0 (multicast), shall be answered  with a multicast response.</Description>
		<Subprotocol>SOMEIPSRV_SD_BEHAVIOR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>340</ID>
		<API>340</API>
		<Name>SOMEIPSRV_BASIC_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>A service shall be identified using the Service-ID.</Description>
		<Subprotocol>SOMEIPSRV_BASIC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>341</ID>
		<API>341</API>
		<Name>SOMEIPSRV_BASIC_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Service-Instance-IDs of 0x0000 and 0xFFFF shall not be used for a service, since 0x0000 is reserved and 0xFFFF is used to describe all service instances.</Description>
		<Subprotocol>SOMEIPSRV_BASIC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>342</ID>
		<API>342</API>
		<Name>SOMEIPSRV_BASIC_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Methods shall use Method-IDs with the highest bit set to 0, while the Method-Ids highest bit shall be set to 1 for events and notifications of fields. NOTE: Checking for notification.</Description>
		<Subprotocol>SOMEIPSRV_BASIC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>343</ID>
		<API>343</API>
		<Name>SOMEIPSRV_ONWIRE_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>For the response and error message the IP addresses and port number of the transport protocol shall match the request message. NOTE: Checking for Response message.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>344</ID>
		<API>344</API>
		<Name>SOMEIPSRV_ONWIRE_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>With 16 Bit Service-ID and a 16 Bit Method-ID starting with a 0-Bit, this allows
		for up to 65536 services with up to 32768 methods each. NOTE: Checking for 0 bit
		in MSB of Method ID in Response Message.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>345</ID>
		<API>345</API>
		<Name>SOMEIPSRV_ONWIRE_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>When generating a response message, the server has to copy the Request ID from  the request to the response message.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>346</ID>
		<API>346</API>
		<Name>SOMEIPSRV_ONWIRE_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Request IDs might be reused as soon as the response arrived or is not expected to arrive anymore (timeout). NOTE: Testing first condition where response arrived.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>347</ID>
		<API>347</API>
		<Name>SOMEIPSRV_ONWIRE_05</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Protocol Version is an 8 Bit field containing the SOME/IP protocol version, which 
		currently shall be set to 0x01.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>348</ID>
		<API>348</API>
		<Name>SOMEIPSRV_ONWIRE_06</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Interface Version is an 8 Bit field that contains the Major Version of the Service Interface.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>349</ID>
		<API>349</API>
		<Name>SOMEIPSRV_ONWIRE_07</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Message Type field is used to differentiate different types of messages and shall  contain the following values. 0x00 REQUEST A request expecting a response (even void). 0x80 RESPONSE The response message. NOTE: Testing Response message after sending a request.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>350</ID>
		<API>350</API>
		<Name>SOMEIPSRV_ONWIRE_10</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Message Type field is used to differentiate different types of messages and shall contain the following values. 0x81 ERROR The response containing an error.
		NOTE: Checking for error UNKNOWN Service ID.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>351</ID>
		<API>351</API>
		<Name>SOMEIPSRV_ONWIRE_11</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Return Code is used to signal whether a request was successfully been processed. NOTE: Checking for Normal Request Response Communication i.e. Error Code E_OK.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>352</ID>
		<API>352</API>
		<Name>SOMEIPSRV_ONWIRE_12</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Return Code is used to signal whether a request was successfully been
		processed. NOTE: Checking for Error in case of Unknown Method ID in Request
		Response Communication i.e. Error Code E_UNKNOWN_METHOD.</Description>
		<Subprotocol>SOMEIPSRV_ONWIRE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>353</ID>
		<API>353</API>
		<Name>SOMEIPSRV_RPC_01</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The client and server shall use a single TCP connection for all methods, events, and notifications of a service instance. NOTE: This test is for methods.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>354</ID>
		<API>354</API>
		<Name>SOMEIPSRV_RPC_02</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The client and server shall use a single TCP connection for all methods, events,  and notifications of a service instance. NOTE: This test is for Notifications.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>355</ID>
		<API>355</API>
		<Name>SOMEIPSRV_RPC_03</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The getter of a field shall be a request/response call that has an empty payload in the request message and the value of the field in the payload of the response message.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>356</ID>
		<API>356</API>
		<Name>SOMEIPSRV_RPC_04</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Requests without response message are called fire. The implementation is  basically the same as for Request/Response with the following differences: There is no response message. The message type is set to REQUEST_NO_RETURN (i.e. 0x01).</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>357</ID>
		<API>357</API>
		<Name>SOMEIPSRV_RPC_05</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Fire  Forget messages shall not return an error. The system shall not return an error message for fire methods.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>358</ID>
		<API>358</API>
		<Name>SOMEIPSRV_RPC_06</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The Error Handling is based on an 8 Bit Std_returnType . The two most  significant bits are reserved and shall be set to 0.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>359</ID>
		<API>359</API>
		<Name>SOMEIPSRV_RPC_07</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The receiver of a return code shall ignore the values of the two most significant bits.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>360</ID>
		<API>360</API>
		<Name>SOMEIPSRV_RPC_08</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>Implementations shall not answer with errors to SOME/IP message already carrying an error (i.e. return code 0x01 - 0x1f).</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>361</ID>
		<API>361</API>
		<Name>SOMEIPSRV_RPC_09</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>For request/response methods the error message shall copy over the fields of the SOME/IP header (i.e. Message ID, Request ID, and Interface Version) but not the payload. In addition Message Type and Return Code have to be set to the appropriate values. NOTE: Checking for No Payload in Error message.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>362</ID>
		<API>362</API>
		<Name>SOMEIPSRV_RPC_10</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The system shall not return an error message for events/notifications and fire methods if the Message Type is set incorrectly to Request or Response.
		NOTE: Checking for Fire and Forget Method.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>363</ID>
		<API>363</API>
		<Name>SOMEIPSRV_RPC_11</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>The setter of a field shall be a request/response call that has the desired valued of the field in the payload of the request message and the value that was set to field in the payload of the response message.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>364</ID>
		<API>364</API>
		<Name>SOMEIPSRV_RPC_13</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>While different Services shall be able to share the same port number of the transport  layer protocol used, multiple Service-Instances of the same service on one single ECU shall listen on different ports per Service-Instance. NOTE: Checking For case-Different Services same port.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>365</ID>
		<API>365</API>
		<Name>SOMEIPSRV_RPC_14</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>While different Services shall be able to share the same port number of the transport layer protocol used, multiple Service-Instances of the same service on one single ECU shall listen on different ports per Service-Instance. NOTE: Checking For case-Different instances of same Service different port.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>366</ID>
		<API>366</API>
		<Name>SOMEIPSRV_RPC_17</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>When having more than one instance of a service a TCP connection per services instance is needed.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>367</ID>
		<API>367</API>
		<Name>SOMEIPSRV_RPC_18</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>For request/response methods the error message shall copy over the fields of the  SOME/IP header (i.e. Message ID, Request ID, and Interface Version) but not the payload. In addition Message Type and Return Code have to be set to the appropriate values. NOTE: Checking For Message ID.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>368</ID>
		<API>368</API>
		<Name>SOMEIPSRV_RPC_19</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>For request/response methods the error message shall copy over the fields of the  SOME/IP header (i.e. Message ID, Request ID, and Interface Version) but not the payload. In addition Message Type and Return Code have to be set to the appropriate values. NOTE: Checking For Request ID.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>369</ID>
		<API>369</API>
		<Name>SOMEIPSRV_RPC_20</Name>
		<Protocol>SOMEIP</Protocol>
		<Description>For request/response methods the error message shall copy over the fields of the SOME/IP header (i.e. Message ID, Request ID, and Interface Version) but not the payload. In addition Message Type and Return Code have to be set to the appropriate values. NOTE: Checking For Interface Version.</Description>
		<Subprotocol>SOMEIPSRV_RPC</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>370</ID>
		<API>370</API>
		<Name>SOMEIP_ETS_001</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>371</ID>
		<API>371</API>
		<Name>SOMEIP_ETS_002</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>372</ID>
		<API>372</API>
		<Name>SOMEIP_ETS_003</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>373</ID>
		<API>373</API>
		<Name>SOMEIP_ETS_004</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>374</ID>
		<API>374</API>
		<Name>SOMEIP_ETS_005</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>375</ID>
		<API>375</API>
		<Name>SOMEIP_ETS_007</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>376</ID>
		<API>376</API>
		<Name>SOMEIP_ETS_008</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>377</ID>
		<API>377</API>
		<Name>SOMEIP_ETS_009</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>378</ID>
		<API>378</API>
		<Name>SOMEIP_ETS_019</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>379</ID>
		<API>379</API>
		<Name>SOMEIP_ETS_021</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>380</ID>
		<API>380</API>
		<Name>SOMEIP_ETS_022</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>381</ID>
		<API>381</API>
		<Name>SOMEIP_ETS_027</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>382</ID>
		<API>382</API>
		<Name>SOMEIP_ETS_028</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>383</ID>
		<API>383</API>
		<Name>SOMEIP_ETS_029</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>384</ID>
		<API>384</API>
		<Name>SOMEIP_ETS_030</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>385</ID>
		<API>385</API>
		<Name>SOMEIP_ETS_031</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>386</ID>
		<API>386</API>
		<Name>SOMEIP_ETS_032</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>387</ID>
		<API>387</API>
		<Name>SOMEIP_ETS_033</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>388</ID>
		<API>388</API>
		<Name>SOMEIP_ETS_034</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>389</ID>
		<API>389</API>
		<Name>SOMEIP_ETS_035</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>390</ID>
		<API>390</API>
		<Name>SOMEIP_ETS_037</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>391</ID>
		<API>391</API>
		<Name>SOMEIP_ETS_038</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>392</ID>
		<API>392</API>
		<Name>SOMEIP_ETS_039</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>393</ID>
		<API>393</API>
		<Name>SOMEIP_ETS_040</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>394</ID>
		<API>394</API>
		<Name>SOMEIP_ETS_041</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>395</ID>
		<API>395</API>
		<Name>SOMEIP_ETS_042</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>396</ID>
		<API>396</API>
		<Name>SOMEIP_ETS_043</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>397</ID>
		<API>397</API>
		<Name>SOMEIP_ETS_044</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>398</ID>
		<API>398</API>
		<Name>SOMEIP_ETS_045</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>399</ID>
		<API>399</API>
		<Name>SOMEIP_ETS_046</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>400</ID>
		<API>400</API>
		<Name>SOMEIP_ETS_047</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>401</ID>
		<API>401</API>
		<Name>SOMEIP_ETS_048</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>402</ID>
		<API>402</API>
		<Name>SOMEIP_ETS_049</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>403</ID>
		<API>403</API>
		<Name>SOMEIP_ETS_050</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>404</ID>
		<API>404</API>
		<Name>SOMEIP_ETS_051</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>405</ID>
		<API>405</API>
		<Name>SOMEIP_ETS_052</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>406</ID>
		<API>406</API>
		<Name>SOMEIP_ETS_053</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>407</ID>
		<API>407</API>
		<Name>SOMEIP_ETS_054</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>408</ID>
		<API>408</API>
		<Name>SOMEIP_ETS_055</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>409</ID>
		<API>409</API>
		<Name>SOMEIP_ETS_058</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>410</ID>
		<API>410</API>
		<Name>SOMEIP_ETS_059</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>411</ID>
		<API>411</API>
		<Name>SOMEIP_ETS_060</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>412</ID>
		<API>412</API>
		<Name>SOMEIP_ETS_061</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>413</ID>
		<API>413</API>
		<Name>SOMEIP_ETS_063</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>414</ID>
		<API>414</API>
		<Name>SOMEIP_ETS_064</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>415</ID>
		<API>415</API>
		<Name>SOMEIP_ETS_065</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>416</ID>
		<API>416</API>
		<Name>SOMEIP_ETS_066</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>417</ID>
		<API>417</API>
		<Name>SOMEIP_ETS_067</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>418</ID>
		<API>418</API>
		<Name>SOMEIP_ETS_068</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>419</ID>
		<API>419</API>
		<Name>SOMEIP_ETS_069</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>420</ID>
		<API>420</API>
		<Name>SOMEIP_ETS_070</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>421</ID>
		<API>421</API>
		<Name>SOMEIP_ETS_071</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>422</ID>
		<API>422</API>
		<Name>SOMEIP_ETS_072</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>423</ID>
		<API>423</API>
		<Name>SOMEIP_ETS_073</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>424</ID>
		<API>424</API>
		<Name>SOMEIP_ETS_074</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>425</ID>
		<API>425</API>
		<Name>SOMEIP_ETS_075</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>426</ID>
		<API>426</API>
		<Name>SOMEIP_ETS_076</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>427</ID>
		<API>427</API>
		<Name>SOMEIP_ETS_077</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>428</ID>
		<API>428</API>
		<Name>SOMEIP_ETS_078</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>429</ID>
		<API>429</API>
		<Name>SOMEIP_ETS_081</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>430</ID>
		<API>430</API>
		<Name>SOMEIP_ETS_082</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>431</ID>
		<API>431</API>
		<Name>SOMEIP_ETS_084</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>432</ID>
		<API>432</API>
		<Name>SOMEIP_ETS_085</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>433</ID>
		<API>433</API>
		<Name>SOMEIP_ETS_086</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>434</ID>
		<API>434</API>
		<Name>SOMEIP_ETS_087</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>435</ID>
		<API>435</API>
		<Name>SOMEIP_ETS_088</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>436</ID>
		<API>436</API>
		<Name>SOMEIP_ETS_089</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>437</ID>
		<API>437</API>
		<Name>SOMEIP_ETS_091</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>438</ID>
		<API>438</API>
		<Name>SOMEIP_ETS_092</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>439</ID>
		<API>439</API>
		<Name>SOMEIP_ETS_093</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>440</ID>
		<API>440</API>
		<Name>SOMEIP_ETS_094</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>441</ID>
		<API>441</API>
		<Name>SOMEIP_ETS_095</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>442</ID>
		<API>442</API>
		<Name>SOMEIP_ETS_096</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>443</ID>
		<API>443</API>
		<Name>SOMEIP_ETS_097</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>444</ID>
		<API>444</API>
		<Name>SOMEIP_ETS_098</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>445</ID>
		<API>445</API>
		<Name>SOMEIP_ETS_099</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>446</ID>
		<API>446</API>
		<Name>SOMEIP_ETS_100</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>447</ID>
		<API>447</API>
		<Name>SOMEIP_ETS_101</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>448</ID>
		<API>448</API>
		<Name>SOMEIP_ETS_103</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>449</ID>
		<API>449</API>
		<Name>SOMEIP_ETS_104</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>450</ID>
		<API>450</API>
		<Name>SOMEIP_ETS_105</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>451</ID>
		<API>451</API>
		<Name>SOMEIP_ETS_106</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>452</ID>
		<API>452</API>
		<Name>SOMEIP_ETS_107</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>453</ID>
		<API>453</API>
		<Name>SOMEIP_ETS_108</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>454</ID>
		<API>454</API>
		<Name>SOMEIP_ETS_109</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>455</ID>
		<API>455</API>
		<Name>SOMEIP_ETS_110</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>456</ID>
		<API>456</API>
		<Name>SOMEIP_ETS_111</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>457</ID>
		<API>457</API>
		<Name>SOMEIP_ETS_112</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>458</ID>
		<API>458</API>
		<Name>SOMEIP_ETS_113</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>459</ID>
		<API>459</API>
		<Name>SOMEIP_ETS_114</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>460</ID>
		<API>460</API>
		<Name>SOMEIP_ETS_115</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>461</ID>
		<API>461</API>
		<Name>SOMEIP_ETS_116</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>462</ID>
		<API>462</API>
		<Name>SOMEIP_ETS_117</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>463</ID>
		<API>463</API>
		<Name>SOMEIP_ETS_118</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>464</ID>
		<API>464</API>
		<Name>SOMEIP_ETS_119</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>465</ID>
		<API>465</API>
		<Name>SOMEIP_ETS_120</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>466</ID>
		<API>466</API>
		<Name>SOMEIP_ETS_121</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>467</ID>
		<API>467</API>
		<Name>SOMEIP_ETS_122</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>468</ID>
		<API>468</API>
		<Name>SOMEIP_ETS_123</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>469</ID>
		<API>469</API>
		<Name>SOMEIP_ETS_124</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>470</ID>
		<API>470</API>
		<Name>SOMEIP_ETS_125</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>471</ID>
		<API>471</API>
		<Name>SOMEIP_ETS_127</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>472</ID>
		<API>472</API>
		<Name>SOMEIP_ETS_128</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>473</ID>
		<API>473</API>
		<Name>SOMEIP_ETS_130</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>474</ID>
		<API>474</API>
		<Name>SOMEIP_ETS_134</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>475</ID>
		<API>475</API>
		<Name>SOMEIP_ETS_135</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>476</ID>
		<API>476</API>
		<Name>SOMEIP_ETS_136</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>477</ID>
		<API>477</API>
		<Name>SOMEIP_ETS_137</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>478</ID>
		<API>478</API>
		<Name>SOMEIP_ETS_138</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>479</ID>
		<API>479</API>
		<Name>SOMEIP_ETS_139</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>480</ID>
		<API>480</API>
		<Name>SOMEIP_ETS_140</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>481</ID>
		<API>481</API>
		<Name>SOMEIP_ETS_141</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>482</ID>
		<API>482</API>
		<Name>SOMEIP_ETS_142</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>483</ID>
		<API>483</API>
		<Name>SOMEIP_ETS_143</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>484</ID>
		<API>484</API>
		<Name>SOMEIP_ETS_144</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>485</ID>
		<API>485</API>
		<Name>SOMEIP_ETS_146</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>486</ID>
		<API>486</API>
		<Name>SOMEIP_ETS_147</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>487</ID>
		<API>487</API>
		<Name>SOMEIP_ETS_148</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>488</ID>
		<API>488</API>
		<Name>SOMEIP_ETS_149</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>489</ID>
		<API>489</API>
		<Name>SOMEIP_ETS_150</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>490</ID>
		<API>490</API>
		<Name>SOMEIP_ETS_151</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>491</ID>
		<API>491</API>
		<Name>SOMEIP_ETS_152</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>492</ID>
		<API>492</API>
		<Name>SOMEIP_ETS_153</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>493</ID>
		<API>493</API>
		<Name>SOMEIP_ETS_154</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>494</ID>
		<API>494</API>
		<Name>SOMEIP_ETS_155</Name>
		<Protocol>SOMEIP</Protocol>
		<Description></Description>
		<Subprotocol>SOMEIP_ETS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>495</ID>
		<API>495</API>
		<Name>TCP_CLOSING_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD allow a received RST segment to include data </Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>
	
	<Test>
		<ID>496</ID>
		<API>496</API>
		<Name>TCP_CLOSING_06</Name>
		<Protocol>TCP</Protocol>
		<Description>Local user initiates the close, a FIN segment can be constructed and placed on the outgoing segment queue</Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>497</ID>
		<API>497</API>
		<Name>TCP_CLOSING_07</Name>
		<Protocol>TCP</Protocol>
		<Description>Local user initiates the close, TCP enters the FIN-WAIT-1 state. RECEIVEs are allowed in this state.</Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>498</ID>
		<API>498</API>
		<Name>TCP_CLOSING_08</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP enters the FIN-WAIT-2 state. RECEIVEs are allowed in this state.</Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>499</ID>
		<API>499</API>
		<Name>TCP_CLOSING_09</Name>
		<Protocol>TCP</Protocol>
		<Description>If an unsolicited FIN arrives from the network TCP enters the CLOSE_WAIT state. TCP can send any remaining data. </Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>500</ID>
		<API>500</API>
		<Name>TCP_CLOSING_13</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP in a CLOSED state, MUST ignore a RST control message</Description>
		<Subprotocol>TCP_CLOSING</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>501</ID>
		<API>501</API>
		<Name>TCP_PROBING_WINDOWS_02</Name>
		<Protocol>TCP</Protocol>
		<Description>The windows size MUST be treated as an unsigned number</Description>
		<Subprotocol>TCP_PROBING_WINDOWS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>502</ID>
		<API>502</API>
		<Name>TCP_PROBING_WINDOWS_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST follow the Karn's algorithm </Description>
		<Subprotocol>TCP_PROBING_WINDOWS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>503</ID>
		<API>503</API>
		<Name>TCP_PROBING_WINDOWS_04</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST include \"exponential backoff\" (check that it increases) for successive RTO values for sending data segments</Description>
		<Subprotocol>TCP_PROBING_WINDOWS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>504</ID>
		<API>504</API>
		<Name>TCP_PROBING_WINDOWS_05</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP MUST include \"exponential backoff\" (check that it increases) for successive RTO values for sending SYN segments</Description>
		<Subprotocol>TCP_PROBING_WINDOWS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>505</ID>
		<API>505</API>
		<Name>TCP_PROBING_WINDOWS_06</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD use RTO = 1 sec initially (RFC 6298)</Description>
		<Subprotocol>TCP_PROBING_WINDOWS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>506</ID>
		<API>506</API>
		<Name>TCP_NAGLE_02</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD implement the Nagle Algorithm, i.e., buffer all the user data, regardless of PSH, until the outstanding data has been acknowledged</Description>
		<Subprotocol>TCP_NAGLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>507</ID>
		<API>507</API>
		<Name>TCP_NAGLE_03</Name>
		<Protocol>TCP</Protocol>
		<Description>TCP SHOULD implement the Nagle Algorithm, i.e., it buffers all user data, regardless of PSH bit, until the TCP can send a full-sized segment</Description>
		<Subprotocol>TCP_NAGLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>508</ID>
		<API>508</API>
		<Name>TCP_CONNECTION_ESTAB_01</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUIT is requested to open a TCP passive socket and receive multiple Tcp Segments from 3 different ports containing SYN flag indicating a value of 1 then DUT opens a TCP passive socket and sends a TCP Segment to each sending port containing SYN and ACK flags indicating a value of 1.</Description>
		<Subprotocol>TCP_CONNECTION_ESTAB</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>509</ID>
		<API>509</API>
		<Name>TCP_CONNECTION_ESTAB_02</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT is requested to open multiple TCP passive sockets and DUT receives multiple Tcp Segments through these sockets containing SYN Flag indicating a value of 1 Then DUT opens a TCP passive sockets and DUT sends multiple TCP segments to the sending port containing SYN and ACK Flags indicating a value of 1</Description>
		<Subprotocol>TCP_CONNECTION_ESTAB</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>510</ID>
		<API>510</API>
		<Name>TCP_CONNECTION_ESTAB_03</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT is requested to open multiple TCP active sockets and DUT receives Tcp Segments with SYN,ACK Flags set to 1 (After that DUT sends SYN) Then DUT opens multiple TCP active sockets and DUT sends multiple Tcp Segments from the open active sockets containing SYN flag indicating a value of 1 and DUT receives SYN ACK as a resonpse to its SYN and DUT sends multiple TCP segments from the open active sockets containing ACK flag indicating a value of 1. </Description>
		<Subprotocol>TCP_CONNECTION_ESTAB</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>511</ID>
		<API>511</API>
		<Name>TCP_CONNECTION_ESTAB_07</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a FIN packet then DUT sends an ACK packet and DUT sends a 'FIN s in response to user's 'Close' request and DUT moves to 'CLOSED' state.</Description>
		<Subprotocol>TCP_CONNECTION_ESTAB</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>512</ID>
		<API>512</API>
		<Name>TCP_HEADER_01</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a valid 'TCP packet then DUT sends and ACK </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>513</ID>
		<API>513</API>
		<Name>TCP_HEADER_02</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a valid 'TCP packet then DUT sends and ACK </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>
	
	<Test>
		<ID>514</ID>
		<API>514</API>
		<Name>TCP_HEADER_04</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing a Source Port indicating a value different from PORT1 containing a sequence number indicating SEQ1 then DUT discards the TCP packet and optionally DUT sends a RST packet </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>515</ID>
		<API>515</API>
		<Name>TCP_HEADER_05</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing a Reserved field indicating  a zero value then DUT accepts the TCP packet </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>516</ID>
		<API>516</API>
		<Name>TCP_HEADER_06</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a 'TCP packet containing 'Reserved field indicating  a non-zero value then DUT ignores the 'Reserved' field and DUT accepts the 'TCP packet' </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>517</ID>
		<API>517</API>
		<Name>TCP_HEADER_07</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing Data Offset indicating  a value less than 5 and non-zero then DUT discards TCP packet </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>518</ID>
		<API>518</API>
		<Name>TCP_HEADER_08</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing Data Offset indicating  a value greater than the actual value then DUT discards TCP packet </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>519</ID>
		<API>519</API>
		<Name>TCP_HEADER_09</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing a Checksum indicating a value of 0 then DUT discards the TCP packet and sends no ACK back </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>520</ID>
		<API>520</API>
		<Name>TCP_HEADER_11</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing SYN = 1 and containing IP Destination Address indicating a value of multicastAddress then Discards the TCP packet and sends no ACK back. </Description>
		<Subprotocol>TCP_HEADER</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>521</ID>
		<API>521</API>
		<Name>TCP_SEQUENCE_01</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a SYN packet containing Sequence Number indicating ISN then DUT sends an ACK containing an Acknowledgment Number indicating ISN+1</Description>
		<Subprotocol>TCP_SEQUENCE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>522</ID>
		<API>522</API>
		<Name>TCP_SEQUENCE_02</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a SYN,ACK packet containing Sequence Number indicating ISN then DUT sends an ACK packet containing Acknowledgment Number indicating ISN +1</Description>
		<Subprotocol>TCP_SEQUENCE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>523</ID>
		<API>523</API>
		<Name>TCP_SEQUENCE_03</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a SYN packet containing Sequence Number indicating a zero value then DUT accepts the TCP packet</Description>
		<Subprotocol>TCP_SEQUENCE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>524</ID>
		<API>524</API>
		<Name>TCP_SEQUENCE_04</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing Sequence Number indicating SeqMaxVal value then DUT accepts the TCP packet and DUT sends an SYN,ACK packet containing Acknowledgment Number indicating 0</Description>
		<Subprotocol>TCP_SEQUENCE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>525</ID>
		<API>525</API>
		<Name>TCP_SEQUENCE_05</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a severalTCP packets containing SEQ indicating values incremented correctly.then DUT sends an ACK for every received TCP Segments</Description>
		<Subprotocol>TCP_SEQUENCE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>526</ID>
		<API>526</API>
		<Name>TCP_ACKNOWLEDGEMENT_02</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing ACK flag indicating a value of 1 and  a payload then Sends an ACK containing Ack Number indicating the expected value</Description>
		<Subprotocol>TCP_ACKNOWLEDGEMENT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>527</ID>
		<API>527</API>
		<Name>TCP_ACKNOWLEDGEMENT_03</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT has no data left to send and DUT receives a TCP packet then DUT sends an ACK containing an Ack Number indicating the expected value.</Description>
		<Subprotocol>TCP_ACKNOWLEDGEMENT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>528</ID>
		<API>528</API>
		<Name>TCP_ACKNOWLEDGEMENT_04</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives an ACK containing Length indicating a value of 0 (an empty ACK, no piggybagging) then DUT does not send an RST and DUT ends connection with the expected ACK number</Description>
		<Subprotocol>TCP_ACKNOWLEDGEMENT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>529</ID>
		<API>529</API>
		<Name>TCP_CONTROL_FLAGS_05</Name>
		<Protocol>TCP</Protocol>
		<Description>Ensure that when DUT receives a TCP packet containing URG flag indicating a value of 1 then DUT sends an ACK containing an Ack Number indicating the expected value. </Description>
		<Subprotocol>TCP_CONTROL_FLAGS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>530</ID>
		<API>530</API>
		<Name>TCP_CONTROL_FLAGS_08</Name>
		<Protocol>TCP</Protocol>
		<Description>An old duplicate SYN arrives at DUT. DUT cannot tell that this is an old duplicate, so it responds normally.  The Tester simulates that the ACK field is incorrect and returns a RST with its SEQ field selected to make the segment believable. DUT, on receiving the RST, returns to the LISTEN state.</Description>
		<Subprotocol>TCP_CONTROL_FLAGS</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>531</ID>
		<API>531</API>
		<Name>TCP_CALL_RECEIVE_04</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_CALL_RECEIVE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>532</ID>
		<API>532</API>
		<Name>TCP_CALL_RECEIVE_05</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_CALL_RECEIVE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>533</ID>
		<API>533</API>
		<Name>TCP_CALL_ABORT_02</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_CALL_ABORT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>534</ID>
		<API>534</API>
		<Name>TCP_CALL_ABORT_03</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_CALL_ABORT</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>535</ID>
		<API>535</API>
		<Name>TCP_NAGLE_02</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_NAGLE</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>536</ID>
		<API>536</API>
		<Name>TCP_FLAGS_INVALID_14</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_FLAGS_INVALID</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>

	<Test>
		<ID>537</ID>
		<API>537</API>
		<Name>TCP_URGENT_PTR_04</Name>
		<Protocol>TCP</Protocol>
		<Description></Description>
		<Subprotocol>TCP_URGENT_PTR</Subprotocol>
		<Status>Not_Checked</Status>
	</Test>
</Test_Suite>